// NOTE: requires are 'managed' by the Makefile; check rule for 'bin/test_thash_%.jpp'

export fn thash<INBLOCKS>(reg u64 _out _in _pub_seed _addr)
{
  stack u8[SPX_N] out;
  stack u8[INBLOCKS*SPX_N] in;
  stack u8[SPX_N] pub_seed;
  stack u32[8] addr;

  reg ptr u8[SPX_N] out_p;
  reg ptr u8[INBLOCKS*SPX_N] in_p;
  reg ptr u8[SPX_N] pub_seed_p;
  reg ptr u32[8] addr_p;

  reg u64 i;
  reg u8 t; 
  reg u32 u;

  stack u64 _out_s _in_s _pub_seed_s _addr_s;
  
  // Load in
  i = 0;
  while (i < INBLOCKS * SPX_N) {
    t = (u8)[_in + i];
    in[(int) i] = t;
    i += 1;
  }


  // Load pub_seed
  i = 0;
  while (i < SPX_N) {
    t = (u8)[_pub_seed + i];
    pub_seed[(int) i] = t;
    i += 1;
  }

  // Load address (TODO: Maybe use a for loop because the size of the array is always the same (8) and short (??))
  i = 0;
  while (i < 8) {
    u = (u32)[_addr + 4 * i]; // 8 * 4 = 32
    addr[(int) i] = u;
    i += 1;
 }

 // Spill to the stack
 _out_s = _out;
 _in_s = _in;
 _pub_seed_s = _pub_seed;
 _addr_s = _addr;

  out_p = out;
  in_p = in;
  pub_seed_p = pub_seed;
  addr_p = addr;

  out_p = __thash<INBLOCKS>(out_p, in_p, pub_seed_p, addr_p);
  out = out_p;

  _out = _out_s;

  // write result
  i = 0;
  while (i < SPX_N) {
    t = out[(int) i];
    (u8)[_out + i] = t;
    i += 1;
  }
}//<>
