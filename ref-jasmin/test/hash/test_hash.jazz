from Sphincs require "hash/hash_shake.jtmpl"

inline fn __load_addr(reg ptr u32[8] addr, reg u64 p) -> reg ptr u32[8]
{
  inline int i;
  reg u32 t;

  for i=0 to 8
  { t = (u32)[p + 4*i];
    addr[i] = t;
  }

  return addr;
}

inline fn __load_R_pk(
  reg ptr u8[SPX_N] R,
  reg ptr u8[SPX_PK_BYTES] pk,
  reg u64 addr
) -> reg ptr u8[SPX_N], reg ptr u8[SPX_PK_BYTES]
{
  inline int i;
  reg u8 t;

  for i = 0 to SPX_N {
    t = (u8)[addr + i];
    R[i] = t;
  }

  for i = 0 to SPX_PK_BYTES {
    t = (u8)[addr + SPX_N + i];
    pk[i] = t;
  }

  return R, pk;
}

inline fn __load_ctx(
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg u64 addr
) -> reg ptr u8[SPX_N], reg ptr u8[SPX_N]
{
  inline int i;
  reg u8 t;

  for i = 0 to SPX_N {
    t = [addr + i];
    pub_seed[i] = t;

    t = [addr + SPX_N + i];
    sk_seed[i] = t;
  }

  return pub_seed, sk_seed;
}

export fn prf_addr_jazz(reg u64 _out _pub_seed _sk_seed _addr) {
  stack u8[32] addr;
  reg ptr u8[32] addr_p;

  stack u8[SPX_N] pub_seed;
  reg ptr u8[SPX_N] pub_seed_p;

  stack u8[SPX_N] sk_seed;
  reg ptr u8[SPX_N] sk_seed_p;

  stack u8[SPX_N] out;
  reg ptr u8[SPX_N] out_p;

  inline int i;
  reg u8 t;

  addr_p = addr;
  addr_p = __load_addr(addr_p, _addr);
  
  for i = 0 to SPX_N {
    t = (u8)[_pub_seed + i];
    pub_seed[i] = t;

    t = (u8)[_sk_seed + i];
    sk_seed[i] = t;
  }

  out_p = out;
  pub_seed_p = pub_seed;
  sk_seed_p = sk_seed;

  out_p = __prf_addr(out_p, pub_seed_p, sk_seed_p, addr_p);
  out = out_p;

  for i = 0 to SPX_N {
    t = out[i];
    (u8)[_out + i] = t;
  }
}

export fn gen_msg_random<MLEN>(
  reg u64 _R _sk_prf _optrand _m
) {

  stack u8[SPX_N] R;
  stack u8[SPX_N] sk_prf;
  stack u8[SPX_N] optrand;
  stack u8[MLEN] m;

  reg ptr u8[SPX_N] R_p;
  reg const ptr u8[SPX_N] sk_prf_p;
  reg const ptr u8[SPX_N] optrand_p;
  reg const ptr u8[MLEN]  m_p;

  inline int i;
  reg u8 t;

  for i = 0 to SPX_N {
    t = (u8)[_R + i];
    R[i] = t;

    t = (u8)[_sk_prf + i];
    sk_prf[i] = t;

    t = (u8)[_optrand + i];
    optrand[i] = t;
  }

  R_p = R; sk_prf_p = sk_prf; optrand_p = optrand; m_p = m;
  R_p = __gen_message_random<MLEN>(R_p, sk_prf_p, optrand_p, m_p);
  R = R_p;

  for i = 0 to SPX_N {
    t = R[i];
    (u8)[_R + i] = t;
  }
}//<>


export fn hash_message_jazz<MSG_LEN>(reg u64 _digest _tree _leaf_idx _R_pk _msg  _ctx) -> reg u32
{
  stack u8[SPX_DGST_BYTES] digest;

  stack u8[SPX_N] R;
  reg ptr u8[SPX_N] R_p;

  reg u64 tree;
  reg u32 leaf_idx;

  stack u8[SPX_PK_BYTES] pk;
  reg ptr u8[SPX_PK_BYTES] pk_p;

  stack u8[MSG_LEN] msg;
  reg ptr u8[MSG_LEN] msg_p;

  stack u8[SPX_N] pub_seed sk_seed;
  reg ptr u8[SPX_N] pub_seed_p sk_seed_p;

  reg u8 t;
  inline int i;

  // Load R & pk
  R_p = R; pk_p = pk;
  R_p, pk_p = __load_R_pk(R_p, pk_p, _R_pk);
  R = R_p; pk = pk_p;

  tree = [_tree];
  leaf_idx = (u32)[_leaf_idx];

  // Load msg
  for i = 0 to MSG_LEN {
    t = (u8)[_msg + i];
    msg[i] = t;
  }

  // Load CTX
  pub_seed_p = pub_seed; sk_seed_p = sk_seed;
  pub_seed_p, sk_seed_p = __load_ctx(pub_seed_p, sk_seed_p, _ctx);

  // Compute result
  msg_p = msg;
  digest, tree, leaf_idx = __hash_message<MSG_LEN>(digest, tree, leaf_idx, R_p, pk_p, msg_p);

  // Write results
  for i = 0 to SPX_DGST_BYTES {
    t = digest[i];
    (u8)[_digest + i] = t;
  }

  [_tree] = tree;
  // [_leaf_idx] = leaf_idx; // typing error: can not implicitly cast u32 into u64
  return leaf_idx;
}//<>

