import re
import sys

import utils
from generic_fn import GenericFn


class Task:
    """
    Represents a task that needs to be resolved by inserting the concrete definition
    for the function in the Jasmin source code.

    Attributes:
        fn_name (str): The name of the function to be resolved in the Jasmin code.
        template_params (dict[str, int]): A map of the (name, value) of the parameters to be used in the function.
        global_params (dict[str, int]): The dictionary of the global parameters
    """

    def __init__(
        self,
        fn_name: str,
        template_params: dict[str, int],
        global_params: dict[str, int],
        generic_fn_dict: dict[str, GenericFn],
    ):
        self.fn_name = fn_name
        self.template_params = template_params
        self.global_params = global_params
        self.generic_fn_dict = generic_fn_dict

    def __eq__(self, other: object):
        if not isinstance(other, Task):
            return False
        return self.get_generated_fn_name() == other.get_generated_fn_name()

    def __hash__(self):
        # Convert the list to a tuple for hashing (TypeError: unhashable type: 'list')
        return hash(self.get_generated_fn_name())

    def __repr__(self) -> str:
        params_str = ", ".join(
            f"'{key}': {value}" for key, value in self.template_params.items()
        )
        return f"Task[\nfn_name='{self.fn_name}',\ngenerated_fn_name={self.get_generated_fn_name()},\ntemplate_params={{ {params_str} }}\n]\n"

    def get_generated_fn_name(self) -> str:
        """
        Computes the name of the function that will be generated by resolving the current task

        Returns:
            str: Name of the function to instantiate
        """
        generic_fn: GenericFn = None
        try:
            generic_fn = self.generic_fn_dict[self.fn_name]
        except KeyError:
            sys.stderr.write(
                f"Could not find {self.fn_name} in generic_fn_dict in Task.get_generated_fn_name\n"
            )
            sys.exit(-1)

        replacement_dict: dict[str, int] = dict(
            zip(
                generic_fn.params, self.template_params.values()
            )  # NOTE: Only includes the parameters in between <>. Does not include global parameters (defined with `param int` statements)
        )

        replacement_dict.update(
            self.global_params
        )  # Add the global parameters to the replacement dict

        tmp = utils.replace_parameters_in_string(
            "_".join(generic_fn.params), replacement_dict
        )

        return f"{generic_fn.fn_name}_{tmp}"

    def resolve(
        self,
        text: str,
        generic_fn_dict: dict[str, GenericFn],
    ) -> str:
        """
        Resolve the function and return the concrete definition
        """
        pattern = rf"// Place concrete instances of the {self.fn_name} function here"

        generic_fn: GenericFn = None
        try:
            generic_fn = generic_fn_dict[self.fn_name]
        except KeyError:
            sys.stderr.write(
                f"Could not find {self.fn_name} in generic_fn_dict in Task.resolve\n"
            )
            sys.exit(-1)

        replacement_dict: dict[str, int] = dict(
            zip(
                generic_fn.params, self.template_params.values()
            )  # NOTE: Only includes the parameters in between <>. Does not include global parameters (defined with `param int` statements)
        )

        replacement_dict.update(
            self.global_params
        )  # Add the global parameters to the replacement dict

        return re.sub(
            pattern,
            lambda match: match.group()
            + "\n"
            + utils.build_concrete_fn(generic_fn, replacement_dict)
            + "\n",
            text,
        )

    def get_sub_tasks(
        self,
        generic_fn_dict: dict[str, GenericFn],
        context_params: dict[str, int] = None,
        resolved_params: dict[str, int] = None,
    ) -> list["Task"]:
        """
        Get the sub-tasks for the current task by resolving nested generic function calls.
        """
        subtasks: list[Task] = []

        generic_fn: GenericFn = None
        try:
            generic_fn = generic_fn_dict[self.fn_name]
        except KeyError:
            sys.stderr.write(
                f"Could not find {self.fn_name} in generic_fn_dict in Task.get_sub_tasks\n"
            )
            sys.exit(-1)

        resolved_fn_body: str = self.resolve(generic_fn.fn_body, generic_fn_dict)

        # The 1st function call does not have
        if context_params is None:
            context_params = dict(zip(generic_fn.params, self.template_params.values()))
        else:
            tmp = dict(zip(generic_fn.params, self.template_params.values()))
            context_params.update(tmp)

        generic_fn_call_pattern = r"(\w+)<([^>]+)>\(([^)]+)\);"
        for match in re.finditer(generic_fn_call_pattern, resolved_fn_body):
            fn_name, generic_params, _ = match.groups()

            if fn_name == self.fn_name:
                sys.stderr.write(f"Recursive functions not supported: {self.fn_name}\n")
                sys.exit(-1)

            generic_params: list[str] = [p.strip() for p in generic_params.split(",")]

            for param in generic_params:
                eval_dict: dict[
                    str, int
                ] = (
                    self.global_params.copy()
                )  # this dict includes both the global parameters and the template parameters of the function relative to the current task
                eval_dict.update(
                    self.template_params
                )  # this dict includes both the global parameters and the template parameters of the function relative to the current task
                # print('Eval dict') # DEBUG
                # pprint.pprint(eval_dict) # DEBUG
                evaluated_param = eval(param, {}, eval_dict)
                context_params[param] = evaluated_param

            # Not sure why or how this works

            subtask = Task(fn_name, context_params, self.global_params, generic_fn_dict)
            subtasks.append(subtask)

        # Recursive step: Find and collect sub-tasks from the resolved function body
        for subtask in subtasks:
            sub_subtasks = subtask.get_sub_tasks(
                generic_fn_dict,
                context_params,  # Pass resolved_params_local in the recursion
            )
            subtasks.extend(sub_subtasks)

        return subtasks
