from Sphincs require "sign/sign.jtmpl"
from Sphincs require "generic/utils.jtmpl"
from Sphincs require "memset/memset.jinc"
from Sphincs require "memcmp/memcmp.jtmpl"

/*
 * Generates an SPX key pair given a seed of length
 * Format sk: [SK_SEED || SK_PRF || PUB_SEED || root]
 * Format pk: [PUB_SEED || root]
 */
export fn crypto_sign_seed_keypair_jazz(
  reg u64 _pk _sk _seed
) -> reg u64
{
  reg u64 r;

  stack u8[SPX_PK_BYTES] pk;
  reg ptr u8[SPX_PK_BYTES] pk_p;

  stack u8[SPX_SK_BYTES] sk;
  reg ptr u8[SPX_SK_BYTES] sk_p;

  stack u8[CRYPTO_SEEDBYTES] seed;
  reg ptr u8[CRYPTO_SEEDBYTES] seed_p;

  stack u64 s_pk s_sk s_seed;

  pk_p = pk;
  pk_p = __load_u8_array<SPX_PK_BYTES>(pk_p, _pk);

  sk_p = sk;
  sk_p = __load_u8_array<SPX_SK_BYTES>(sk_p, _sk);

  seed_p = seed;
  seed_p = __load_u8_array<CRYPTO_SEEDBYTES>(seed_p, _seed);

  s_pk = _pk; s_sk = _sk;
  pk_p, sk_p = __crypto_sign_seed_keypair(pk_p, sk_p, seed_p);
  _pk = s_pk; _sk = s_sk;

  __store_u8_array<SPX_PK_BYTES>(pk_p, _pk);
  __store_u8_array<SPX_SK_BYTES>(sk_p, _sk);

  ?{}, r = #set0();
  return r;
}

export fn crypto_sign_keypair_jazz(reg u64 _pk _sk) -> reg u64
{
  stack u8[SPX_PK_BYTES] pk;
  reg ptr u8[SPX_PK_BYTES] pk_p;

  stack u8[SPX_SK_BYTES] sk;
  reg ptr u8[SPX_SK_BYTES] sk_p;

  reg u64 r;

  stack u64 s_pk s_sk;

  s_pk = _pk; s_sk = _sk; // spill

  _pk = s_pk; _sk = s_sk; // unspill

  pk_p = pk;
  pk_p = __load_u8_array<SPX_PK_BYTES>(pk_p, _pk);

  sk_p = sk;
  sk_p = __load_u8_array<SPX_SK_BYTES>(sk_p, _sk);

  s_pk = _pk; s_sk = _sk; // spill
  pk_p, sk_p = __crypto_sign_keypair(pk_p, sk_p);
  _pk = s_pk; _sk = s_sk; // unspill

  __store_u8_array<SPX_PK_BYTES>(pk_p, _pk);
  __store_u8_array<SPX_SK_BYTES>(sk_p, _sk);

  ?{}, r = #set0();
  return r;
}

/**
 * Returns an array containing a detached signature.
 * // TODO:
 */
export fn crypto_sign_signature_jazz(
  reg u64 _sig _siglen _m _mlen _sk
) -> reg u64
{
  //////////////////////////////////////////////
  stack u64 s_sig;
  stack u64 s_siglen;
  //////////////////////////////////////////////
  reg u64 res;

  // sk_prf = sk[SPX_N : SPX_N]
  // pk     = sk[2*SPX_N : SPX_N]


  stack u8[SPX_BYTES] sig;
  stack u8[SPX_SK_BYTES] sk;

  sig = __load_u8_array<SPX_BYTES>(sig, _sig);
  sk = __load_u8_array<SPX_SK_BYTES>(sk, _sk);

  s_sig = _sig; s_siglen = _siglen; // spill

  sig = __crypto_sign_signature(sig, sk);

  _sig = s_sig; 
  _siglen = s_siglen;

  __store_u8_array<SPX_BYTES>(sig, _sig);

  [_siglen] = SPX_BYTES;

  ?{}, res = #set0();
  return res;
}

////////////////////
export fn crypto_sign_jazz<MSG_LEN>(
  reg u64 _sm _smlen _m _mlen _sk
) -> reg u64
{
  reg u64 res siglen;

  stack u8[MSG_LEN] m;
  stack u8[SPX_BYTES + SPX_MLEN] sm;

  ?{}, res = #set0();



  return res;
}//<>

export fn crypto_sign_verify(
  reg u64 _sig _siglen _m _mlen _pk
) -> reg u64
{
  reg u64 res;
  reg u8 stop;

  /////////////////////////////////////////
  stack u64 s_sig s_siglen s_m s_mlen s_pk;
  /////////////////////////////////////////

  stack u8[SPX_PK_BYTES] pk;
  stack u8[45] msg;
  stack u8[SPX_BYTES] sig;

  if (_siglen != SPX_BYTES) { res = 1; }

  if (res != 1) {
    pk = __load_u8_array<SPX_PK_BYTES>(pk, _pk);
    sig = __load_u8_array<SPX_BYTES>(sig, _sig);

    // TODO: Load other valuex

    // Spill
    s_sig = _sig;
    s_siglen = _siglen;
    s_m = _m;
    s_mlen = _mlen;
    s_pk = _pk;

    res = __crypto_sign_verify<45>(pk, sig, msg); // TODO: FIXME: Cant use arrays for the message
  }

  return res;
}

/**
 * Verifies a given signature-message pair under a given public key.
 */
 // TODO:
export fn crypto_sign_open_jazz(
  reg u64 _m _mlen _sm _smlen _pk
) -> reg u64
{
  reg u64 res;
  reg u64 verify;
  reg u64 t;

  res = 0;

  if (_smlen < SPX_BYTES) {
    memset_u8(_m, _mlen, 0);
    [_mlen] = 0;
    res = 1;
  }

  if (res != 1) {
    // *mlen = smlen - SPX_BYTES;
    t = _smlen;
    t -= SPX_BYTES;
    [_mlen] = t;

    // verify = __crypto_sign_verify<45>() // TODO: Call __crypto_sign_verify
    if (verify != 0) {
      // Verification failed
      memset_u8(_m, _smlen, 0);
      [_mlen] = 0;
      res = 1;
    } else {
      // Verification was sucessful
      t = [_mlen];
      __memmove_u8(_m, _sm + SPX_BYTES, t);
    }
  }

  return res;
}
