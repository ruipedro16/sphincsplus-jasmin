from Sphincs require "generic/conditions.jinc"
from Sphincs require "generic/utils.jtmpl"

export fn cond_u64_a_below_b_and_a_below_c_jazz(reg u64 a b c _res) {
    reg u8 r;
    reg bool res;

    res = __cond_u64_a_below_b_and_a_below_c(a, b, c);
    r = #SETcc(res);

    (u8)[_res] = r;
}

export fn cond_u32_a_below_b_and_a_below_c_jazz(reg u64 _a _b _c _res) {
    reg u32 a b c;
    reg u8 r;
    reg bool res;

    a = (32u) _a;
    b = (32u) _b;
    c = (32u) _c;

    a = a; b = b; c = c;
    res = __cond_u32_a_below_b_and_a_below_c(a, b, c);
    r = #SETcc(res);

    (u8)[_res] = r;
}

export fn cond_u64_a_dif_b_and_a_dif_c_jazz(reg u64 a b c _res) {
    reg u8 r;
    reg bool res;
    res = __cond_u64_a_dif_b_and_a_dif_c(a, b, c);
    
    r = #SETcc(res);
    (u8)[_res] = r;
}

export fn cond_u64_a_dif_b_and_c_dif_d_jazz(
    reg u64 a b c d _res
)
{
    reg u8 r;
    reg bool res;

    res = __cond_u64_a_dif_b_and_c_dif_d(a, b, c, d);

    r = #SETcc(res);
    (u8)[_res] = r;
}

export fn cond_u32_a_eq_b_and_c_below_d_jazz(
    reg u64 _a _b _c _d _res
)
{
    reg u32 a b c d;
    reg u8 r;
    reg bool res;

    a = (32u) _a;
    b = (32u) _b;
    c = (32u) _c;
    d = (32u) _d;

    res = __cond_u32_a_eq_b_and_c_below_d(a, b, c, d);
    r = #SETcc(res);
    (u8)[_res] = r;
}

export fn zero_array_u32_jazz<INLEN>(reg u64 addr) {
    stack u32[INLEN] a;
    reg ptr u32[INLEN] ap;

    ap = a;
    ap = __load_u32_array<INLEN>(ap, addr);
    ap = __zero_array_u32<INLEN>(ap);
    __store_u32_array<INLEN>(ap, addr);
}//<>

export fn ull_to_bytes_jazz(reg u64 _out in)
{
    stack u8[8] out;
    reg ptr u8[8] out_p;
    out_p = out;
    out_p = __load_u8_array<8>(out_p, _out);
    out_p = __ull_to_bytes(out_p, in);
    __store_u8_array<8>(out_p, _out);
}

export fn ull_to_bytes_t_jazz<OUTLEN>(reg u64 _out in)
{
    stack u8[OUTLEN] out;
    reg ptr u8[OUTLEN] out_p;
    out_p = out;
    out_p = __load_u8_array<OUTLEN>(out_p, _out);
    out_p = __ull_to_bytes_t<OUTLEN>(out_p, in);
    __store_u8_array<OUTLEN>(out_p, _out); 
}//<>

export fn bytes_to_ull_jazz(reg u64 _in) -> reg u64 { 
    reg u64 res; 
    stack u8[8] in; 
    reg ptr u8[8] in_p; 
    
    in_p = in; 
    in_p = __load_u8_array<8>(in_p, _in); 
    res = __bytes_to_ull<8>(res, in_p); 
    in = in_p; 
    
    return res; 
}

export fn bytes_to_ull_jazz_1(reg u64 _in) -> reg u64 { 
    reg u64 res; 
    stack u8[1] in; 
    reg ptr u8[1] in_p; 
    
    in_p = in; 
    in_p = __load_u8_array<1>(in_p, _in); 
    res = __bytes_to_ull<1>(res, in_p); 
    in = in_p; 
    
    return res; 
}

export fn bytes_to_ull_jazz_2(reg u64 _in) -> reg u64 { 
    reg u64 res; 
    stack u8[2] in; 
    reg ptr u8[2] in_p; 
    
    in_p = in; 
    in_p = __load_u8_array<2>(in_p, _in); 
    res = __bytes_to_ull<2>(res, in_p); 
    in = in_p; 
    
    return res; 
}

export fn bytes_to_ull_jazz_3(reg u64 _in) -> reg u64 { 
    reg u64 res; 
    stack u8[3] in; 
    reg ptr u8[3] in_p; 
    
    in_p = in; 
    in_p = __load_u8_array<3>(in_p, _in); 
    res = __bytes_to_ull<3>(res, in_p); 
    in = in_p; 
    
    return res; 
}

export fn bytes_to_ull_jazz_4(reg u64 _in) -> reg u64 { 
    reg u64 res; 
    stack u8[4] in; 
    reg ptr u8[4] in_p; 
    
    in_p = in; 
    in_p = __load_u8_array<4>(in_p, _in); 
    res = __bytes_to_ull<4>(res, in_p); 
    in = in_p; 
    
    return res; 
}

export fn bytes_to_ull_jazz_5(reg u64 _in) -> reg u64 { 
    reg u64 res; 
    stack u8[5] in; 
    reg ptr u8[5] in_p; 
    
    in_p = in; 
    in_p = __load_u8_array<5>(in_p, _in); 
    res = __bytes_to_ull<5>(res, in_p); 
    in = in_p; 
    
    return res; 
}

export fn bytes_to_ull_jazz_6(reg u64 _in) -> reg u64 { 
    reg u64 res; 
    stack u8[6] in; 
    reg ptr u8[6] in_p; 
    
    in_p = in; 
    in_p = __load_u8_array<6>(in_p, _in); 
    res = __bytes_to_ull<6>(res, in_p); 
    in = in_p; 
    
    return res; 
}

export fn bytes_to_ull_jazz_7(reg u64 _in) -> reg u64 { 
    reg u64 res; 
    stack u8[7] in; 
    reg ptr u8[7] in_p; 
    
    in_p = in; 
    in_p = __load_u8_array<7>(in_p, _in); 
    res = __bytes_to_ull<7>(res, in_p); 
    in = in_p; 
    
    return res; 
}

export fn bytes_to_ull_jazz_8(reg u64 _in) -> reg u64 { 
    reg u64 res; 
    stack u8[8] in; 
    reg ptr u8[8] in_p; 
    
    in_p = in; 
    in_p = __load_u8_array<8>(in_p, _in); 
    res = __bytes_to_ull<8>(res, in_p); 
    in = in_p; 
    
    return res; 
}
