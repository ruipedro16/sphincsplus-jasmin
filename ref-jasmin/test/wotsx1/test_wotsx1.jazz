from Sphincs require "wotsx1/wotsx1.jtmpl"
from Sphincs require "generic/utils.jtmpl"

inline fn __load_leaf_info_x1(
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] wots_sig,
  reg u32 wots_sign_leaf,
  reg ptr u32[SPX_WOTS_LEN] steps,
  reg ptr u32[8] leaf_addr pk_addr,
  reg u64 addr
) -> reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES], reg u32, reg ptr u32[SPX_WOTS_LEN],
     reg ptr u32[8], reg ptr u32[8]
{
  reg u64 _addr; 
  addr = addr;

  wots_sig = __load_u8_array<SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES>(wots_sig, _addr);
  _addr += SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES;

  wots_sign_leaf = (u32)[_addr];
  _addr += 4;

  steps = __load_u32_array<SPX_WOTS_LEN>(steps, _addr);
  _addr += 4*SPX_WOTS_LEN;

  leaf_addr = __load_u32_array<8>(leaf_addr, _addr);
  _addr += 4*8;

  pk_addr = __load_u32_array<8>(pk_addr, _addr);

  return wots_sig, wots_sign_leaf, steps, leaf_addr, pk_addr;
}

export fn wots_gen_leafx1_jazz(
  reg u64 _pk _pub_seed _sk_seed _leaf_idx _info
)
{
  stack u8[SPX_PK_BYTES] pk;
  stack u8[SPX_N] pub_seed sk_seed;

  reg u32 leaf_idx;

  // [struct leaf_info]
  stack u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] wots_sig;
  reg u32 wots_sign_leaf;
  stack u32[SPX_WOTS_LEN] steps;
  stack u32[8] leaf_addr pk_addr;
  // [struct leaf_info]

  stack u64 s_pk s_pub_seed s_sk_seed s_leaf_idx s_info;

  pk = __load_u8_array<SPX_PK_BYTES>(pk, _pk);
  pub_seed = __load_u8_array<SPX_N>(pub_seed, _pub_seed);
  sk_seed = __load_u8_array<SPX_N>(sk_seed, _sk_seed);
  leaf_idx = (u32)[_leaf_idx];

  wots_sig, wots_sign_leaf, steps, leaf_addr, pk_addr = __load_leaf_info_x1(wots_sig, wots_sign_leaf, steps, leaf_addr, pk_addr, _info);

  steps = __zero_array_u32<SPX_WOTS_LEN>(steps);

  // Spill
  s_pk = _pk;
  s_pub_seed = _pub_seed;
  s_sk_seed = _sk_seed;
  s_leaf_idx = _leaf_idx;
  s_info = _info;

  pk = __wots_gen_leafx1(pk, pub_seed, sk_seed, leaf_idx, wots_sig, wots_sign_leaf, steps, leaf_addr, pk_addr);

  _pk = s_pk;
  __store_u8_array<SPX_PK_BYTES>(pk, _pk);
}
