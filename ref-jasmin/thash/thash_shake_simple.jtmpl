
from Sphincs require "fips202/shake256_array/shake256.jtmpl"
from Sphincs require "memcpy/memcpy.jtmpl"

inline fn __thash<INBLOCKS>(
  reg ptr u8[SPX_N] out,
  reg ptr u8[INBLOCKS*SPX_N] in,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u32[8] addr
  ) -> reg ptr u8[SPX_N]
{
  // TODO : study how to improve usage: avoid having to use 'SPX_N + SPX_ADDR_BYTES + INBLOCKS*SPX_N' repeatedly
  // - check local parameters // - local defines working as alias

  stack u8[SPX_N + SPX_ADDR_BYTES + INBLOCKS*SPX_N] buf;
  reg ptr u8[SPX_N + SPX_ADDR_BYTES + INBLOCKS*SPX_N] buf_p;

  reg u64 offset;
  stack u64 s_offset;

  stack ptr u8[INBLOCKS*SPX_N] s_in;
  stack ptr u8[SPX_N] s_pub_seed;
  stack ptr u32[8] s_addr;

  buf_p = buf;
  offset = 0;

  buf_p, offset = _x_memcpy_u8u8<SPX_N+SPX_ADDR_BYTES+INBLOCKS*SPX_N, SPX_N>(buf_p, offset, pub_seed);
  buf_p, offset = _x_memcpy_u8u32<SPX_N+SPX_ADDR_BYTES+INBLOCKS*SPX_N, 8>(buf_p, offset, addr);
  buf_p, offset = _x_memcpy_u8u8<SPX_N+SPX_ADDR_BYTES+INBLOCKS*SPX_N, INBLOCKS*SPX_N>(buf_p, offset, in);
  s_in = in; s_addr = addr; s_pub_seed = pub_seed; s_offset = offset; // spill
  out = __shake256<SPX_N,SPX_N+SPX_ADDR_BYTES+INBLOCKS*SPX_N>(out, buf_p);
  in = s_in; addr = s_addr; pub_seed = s_pub_seed; // unspill
  out = out;

  return out;
}//<>

#[returnaddress="stack"]
fn _thash<INBLOCKS>(
  reg ptr u8[SPX_N] out,
  reg ptr u8[INBLOCKS*SPX_N] in,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u32[8] addr
) -> reg ptr u8[SPX_N]
{
  out = __thash<INBLOCKS>(out, in, pub_seed, addr);
  return out;
}//<>

inline fn __thash_<INBLOCKS>(
  reg ptr u8[SPX_N] out,
  reg ptr u8[INBLOCKS*SPX_N] in,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u32[8] addr
) -> reg ptr u8[SPX_N]
{
  out = out; in = in; pub_seed = pub_seed; addr = addr;
  out = _thash<INBLOCKS>(out, in, pub_seed, addr);
  out = out; in = in; pub_seed = pub_seed; addr = addr;

  return out;
}//<>

// /////////////////////////////////////////////////////////////////////////////
inline fn __thash_inplace(
  reg ptr u8[SPX_N] out,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u32[8] addr
  ) -> reg ptr u8[SPX_N]
{
  stack u8[SPX_N + SPX_ADDR_BYTES + SPX_N] buf;
  reg ptr u8[SPX_N + SPX_ADDR_BYTES + SPX_N] buf_p;

  reg u64 offset;
  stack u64 s_offset;

  stack ptr u8[SPX_N] s_pub_seed;
  stack ptr u32[8] s_addr;

  buf_p = buf;
  offset = 0;

  buf_p, offset = _x_memcpy_u8u8<SPX_N+SPX_ADDR_BYTES+SPX_N, SPX_N>(buf_p, offset, pub_seed);
  buf_p, offset = _x_memcpy_u8u32<SPX_N+SPX_ADDR_BYTES+SPX_N, 8>(buf_p, offset, addr);
  buf_p, offset = _x_memcpy_u8u8<SPX_N+SPX_ADDR_BYTES+SPX_N, SPX_N>(buf_p, offset, out);
  s_addr = addr; s_pub_seed = pub_seed; s_offset = offset; // spill
  out = __shake256<SPX_N,SPX_N+SPX_ADDR_BYTES+SPX_N>(out, buf_p);
  addr = s_addr; pub_seed = s_pub_seed; // unspill
  out = out;

  return out;
}//<>

#[returnaddress="stack"]
fn _thash_inplace(
  reg ptr u8[SPX_N] out,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u32[8] addr
) -> reg ptr u8[SPX_N]
{
  out = __thash_inplace(out, pub_seed, addr);
  return out;
}//<>

inline fn __thash_inplace_(
  reg ptr u8[SPX_N] out,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u32[8] addr
) -> reg ptr u8[SPX_N]
{
  out = out; pub_seed = pub_seed; addr = addr;
  out = _thash_inplace(out, pub_seed, addr);
  out = out; pub_seed = pub_seed; addr = addr;

  return out;
}//<>

