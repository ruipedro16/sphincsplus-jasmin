inline fn __zero_array_u32<INLEN>(reg ptr u32[INLEN] a) -> reg ptr u32[INLEN]
{
  reg u32 t;
  reg u64 i;

  t = 0;
  i = 0;
  while (i < INLEN) {
    a[i] = t;
    i += 1;
  }

  return a;
}//<>

inline fn _zero_array_u8<INLEN>(reg ptr u8[INLEN] a) -> reg ptr u8[INLEN]
{
  reg u8 t;
  reg u64 i;

  t = 0;
  i = 0;
  while (i < INLEN) {
    a[i] = t;
    i += 1;
  }

  return a;
}//<>

inline fn __zero_array_u8<INLEN>(reg ptr u8[INLEN] a) -> reg ptr u8[INLEN]
{
  a = a;
  a = _zero_array_u8<INLEN>(a);
  a = a;
  return a;
}//<>

// Used in wots
inline fn __ull_to_bytes(
  reg ptr u8[8] out,
  reg u64 in
) -> reg ptr u8[8]
{
  // for (i = (signed int)outlen - 1; i >= 0; i--) { out[i] = in & 0xff; in = in >> 8; }

  inline int i;

  for i=7 downto -1 {
    out[i] = (8u) in;
    in >>= 8;
  }

  return out;
}

inline fn __ull_to_bytes_t<OUTLEN>(
  reg ptr u8[OUTLEN] out,
  reg u64 in
) -> reg ptr u8[OUTLEN]
{
  inline int i;

  for i=OUTLEN-1 downto -1 {
    out[i] = (8u) in;
    in >>= 8;
  }

  return out;
}//<>

// Only works for 1 
inline fn __bytes_to_ull<INLEN>(reg u64 out, reg ptr u8[INLEN] in) -> reg u64 {
  inline int i;
  inline u64 shift_amount;
  reg u64 t;

  // unsigned long long retval = 0;
  ?{}, out = #set0();

  // for (i = 0; i < inlen; i++) 
  for i=0 to INLEN {
    // retval |= ((unsigned long long)in[i]) << (8 * (inlen - 1 - i));
    shift_amount = 8 * (INLEN - 1 - i);

    t = (64u) in[i];
    ?{}, t = #SHL(t, shift_amount);

    out = #OR(out, t);
  }

  return out;
}//<>

inline fn __bytes_to_ull__8_(reg u64 result, reg ptr u8[8] in) -> reg u64 {
  inline int i;
  inline u64 shift_amount;
  reg u64 t;

  // uint64_t result = 0;
  ?{}, result = #set0();

  // result |= ((uint64_t)byteArray[0]) << 56;
  shift_amount = 56; t = (64u) in[0];
  ?{}, t = #SHL(t, shift_amount);
  result |= t;

  // result |= ((uint64_t)byteArray[1]) << 48;
  shift_amount = 48; t = (64u) in[1];
  ?{}, t = #SHL(t, shift_amount);
  result |= t;

  // result |= ((uint64_t)byteArray[2]) << 40;
  shift_amount = 40; t = (64u) in[2];
  ?{}, t = #SHL(t, shift_amount);
  result |= t;

  // result |= ((uint64_t)byteArray[3]) << 32;
  shift_amount = 32; t = (64u) in[3];
  ?{}, t = #SHL(t, shift_amount);
  result |= t;

  // result |= ((uint64_t)byteArray[4]) << 24;
  shift_amount = 24; t = (64u) in[4];
  ?{}, t = #SHL(t, shift_amount);
  result |= t;

  // result |= ((uint64_t)byteArray[5]) << 16;
  shift_amount = 16; t = (64u) in[5];
  ?{}, t = #SHL(t, shift_amount);
  result |= t;
  
  // result |= ((uint64_t)byteArray[6]) << 8;
  shift_amount = 8; t = (64u) in[6];
  ?{}, t = #SHL(t, shift_amount);
  result |= t;

  // result |= (uint64_t)byteArray[7];
  t = (64u) in[7];
  result |= t;

  return result;
}

//// TODO: The following functions are only used in tests (maybe they shouldnt be in this file)
inline fn __load_u8_array<INLEN>(
  reg ptr u8[INLEN] in,
  reg u64 addr
) -> reg ptr u8[INLEN] 
{
  reg u8 t;
  reg u64 i;

  i = 0;
  while(i < INLEN) { 
    t = (u8)[addr + i];
    in[(int) i] = t;
    i += 1;
  }

  return in;
}//<>

inline fn __load_u32_array<INLEN>(
  reg ptr u32[INLEN] in,
  reg u64 addr
) -> reg ptr u32[INLEN] 
{
  reg u32 t;
  reg u64 i;

  i = 0;
  while(i < INLEN) { 
    t = (u32)[addr + 4*i];
    in[i] = t;
    i += 1;
  }

  return in;
}//<>

inline fn __load_u64_array<INLEN>(
  reg ptr u64[INLEN] in,
  reg u64 addr
) -> reg ptr u64[INLEN] 
{
  reg u64 t;
  reg u64 i;

  i = 0;
  while(i < INLEN) { 
    t = (u64)[addr + 8*i];
    in[i] = t;
    i += 1;
  }

  return in;
}//<>


inline fn __store_u8_array<INLEN>(
  reg ptr u8[INLEN] in,
  reg u64 addr
)
{
  reg u8 t;
  reg u64 i;

  i = 0;
  while (i < INLEN) { 
    t = in[i];
    (u8)[addr + i] = t;
    i += 1;
  }
}//<>

inline fn __store_u32_array<INLEN>(
  reg ptr u32[INLEN] in,
  reg u64 addr
)
{
  reg u32 t;
  reg u64 i;

  i = 0;
  while (i < INLEN) { 
    t = in[(int) i];
    (u32)[addr + 4*i] = t;
    i += 1;
  }
}//<>

inline fn __store_u64_array<INLEN>(
  reg ptr u64[INLEN] in,
  reg u64 addr
)
{
  reg u64 t;
  reg u64 i;

  i = 0;
  while (i < INLEN) {
    t = in[i];
    [addr + 8 * i] = t;
    i += 1;
  }
}//<>
