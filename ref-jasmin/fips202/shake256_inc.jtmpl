from Sphincs require "fips202/keccak1600.jtmpl"
from Sphincs require "generic/conditions.jinc"

////// keccak
inline fn __keccak_inc_init(reg ptr u64[26] state) -> reg ptr u64[26] {
  inline int i;
  reg u64 t;

  ?{}, t = #set0();

  for i = 0 to 26 { state[i] = t; }

  return state;
}

inline fn __keccak_inc_absorb<INLEN>(
  reg ptr u64[26] state,
  reg ptr u8[INLEN] in,
  inline int rate
) -> reg ptr u64[26]
{
  reg u64 inlen offset_in;
  stack u64 s_inlen s_offset_in;

  stack ptr u8[INLEN] s_in;

  reg u8 rate_8;
  stack u8 s_rate_8;

  reg u64 t i u v z;
  stack u64 s_t s_i s_u s_v s_z;

  inlen = INLEN;
  offset_in = 0;

  t = inlen; t += state[25]; // t holds the value of inlen + state[25]
  rate_8 = rate;
  
  while (t >=u rate_8) 
  {
    i = 0;
    t = (64u) rate_8; t -= state[25];

    while (i < t) 
    {
      t = state[25]; 
      t += i;

      u = t;
      t >>= (3 & 63);

      u &= 0x07;
      u <<= (3 & 63);

      z = offset_in;
      z += i;
      v = (64u) in[(int) z];

      v <<= (u & 63);
      state[(int) t] ^= v;

      i += 1;
    }

    t = (64u) rate; t -= state[25];
    inlen -= t;
    offset_in += t;
    state[25] = 0;

    /* Permute state */
      // Spill
      s_in = in;
      s_inlen = inlen;
      s_offset_in = offset_in;
      s_rate_8 = rate_8;
      s_t = t;
      s_i = i;
      s_u = u;
      s_v = v;
      s_z = z;


    //  state[0:25] = _keccakf1600_(state[0:25]);

      // Unspill
      in = s_in;
      inlen = s_inlen;
      offset_in = s_offset_in;
      rate_8 = s_rate_8;
      t = s_t;
      i = s_i;
      u = s_u;
      v = s_v;
      z = s_z;

    t = inlen;
    t += state[25]; // to compute the loop condition
  }

  i = 0;
  while (i < inlen)
  {
    t = state[25]; 
    t += i;

    u = t;
    t >>= (3 & 63);

    u &= 0x07;
    u <<= (3 & 63);

    z = offset_in;
    z += i;
    v = (64u) in[(int) z];
    
    v <<= (u & 63);
    state[(int) t] ^= v;

    i += 1;
  }

  state[25] += inlen;

  return state;
}//<>

inline fn __keccak_inc_squeeze<OUTLEN>(
  reg ptr u8[OUTLEN] out,
  reg ptr u64[26] state,
  reg u64 rate
) -> reg ptr u8[OUTLEN], reg ptr u64[26]  
{
  // Values to spill: out rate i outlen offset_out t u addr
  stack ptr u8[OUTLEN] s_out;
  reg u64 i outlen offset_out;
  reg u64 t u addr; 
  
  stack u64 s_i s_outlen s_offset_out s_rate;
  stack u64 s_t s_u s_addr;

  reg bool cond;
  
  offset_out = 0;
  outlen = OUTLEN;

  i = 0;
  t = state[25];

  /* First consume any bytes we still have sitting around */
  while {
    cond = __cond_u64_a_below_b_and_a_below_c(i, outlen, t);
  } (cond) {
    t = rate;
    t -= state[25];
    t += i; // t holds the value of rate - state[25] + i

    addr = t;
    addr >>= (3 & 63); // addr holds the value off (rate - state[25] + i) >> 3

    t &= 0x07; // t holds the value (rate - state[25] + i) & 0x07
    t <<= (3 & 63); // Same as t *= 8.  t holds the value 8 * [(rate - state[25] + i) & 0x07]

    u = state[(int) addr];
    u >>= (t & 63);
    
    out[(int) i] = (8u) u;

    t = state[25]; // to compute the loop condition
    i += 1;        // to compute the loop condition
  }

  offset_out += i;
  outlen -= i;
  state[25] -= 1;

  /* Then squeeze the remaining necessary blocks */
  while(outlen > 0)
  {
    // Permute state
    s_out = out; s_rate = rate; s_i = i; s_outlen = outlen; s_offset_out = offset_out; s_t = t; s_u = u; s_addr = addr; // spill
    state[0:25] = _keccakf1600_(state[0:25]);
    out = s_out; rate = s_rate; i = s_i; outlen = s_outlen; offset_out = s_offset_out; t = s_t; u = s_u; addr = s_addr; // unspill

    /* Then squeeze the remaining necessary blocks */
    while {
      cond = __cond_u64_a_below_b_and_a_below_c(i, outlen, rate);
    } (cond) {
      t = i;
      t &= 0x07;
      t <<= (3 & 63); // t holds the value of 8 * (i & 0x07)

      addr = i;
      addr >>= (3 & 63); // addr holds the value of i >> 3

      u = state[(int) addr];
      u >>= (t & 63); // u holds the value of state[i >> 3] >> [8 * (i & 0x07)]

      addr = offset_out; 
      addr += i;
      out[(int) addr] = (8u) u;

      i += 1;
    }

    offset_out += i;
    outlen -= i;
    t = rate; t -= i; 
    state[25] = t; // Same as state[25] = rate - i;
  }

  return out, state;
}//<>

inline fn __keccak_inc_finalize(
  reg ptr u64[26] state,
  reg u64 rate,
  reg u8 p
) -> reg ptr u64[26]
{
  reg u64 addr t u;

  t = state[25];
  addr = t;

  t &= 0x07;
  t <<= (3 & 63);
  
  u = (64u) p;
  u <<= (t & 63);

  addr >>= (3 & 63);
  state[(int) addr] ^= u;

  /////

  t = rate;
  t -= 1;

  addr = t;

  t &= 0x07;
  t <<= (3 & 63);

  u = 128;
  u <<= (t & 63);
  
  addr >>= (3 & 63);
  state[(int) addr] ^= u;

  /////

  state[25] = 0;

  return state;
}

////// shake
fn __shake256_inc_init(reg ptr u64[26] state) -> reg ptr u64[26] {
  state = state;
  state = __keccak_inc_init(state);
  return state;
}

inline fn __shake256_inc_init_(
  reg ptr u64[26] state
) -> reg ptr u64[26]
{
  state = state;
  state = __shake256_inc_init(state);
  state = state;
  return state;
}

#[returnaddress="stack"]
fn __shake256_inc_absorb<INLEN>(
  reg ptr u64[26] state,
  reg const ptr u8[INLEN] in
) -> reg ptr u64[26]
{
  inline int rate;

  rate = (1088/8); // = 136

  state = __keccak_inc_absorb<INLEN>(state, in, rate);
  return state;
}//<>

inline fn __shake256_inc_absorb_<INLEN>(
  reg ptr u64[26] state,
  reg const ptr u8[INLEN] in
) -> reg ptr u64[26]
{
  state = state;
  in = in;
  state = __shake256_inc_absorb<INLEN>(state, in);
  state = state;
  in = in;
  return state;
}//<>

inline fn __shake256_inc_finalize(
  reg ptr u64[26] state
) -> reg ptr u64[26] 
{
  reg u64 rate;
  reg u8 trail_byte;

  rate = (1088/8); // = 136
  trail_byte = 0x1F;

  state = __keccak_inc_finalize(state, rate, trail_byte);
  return state;
}

#[returnaddress="stack"]
fn __shake256_inc_squeeze<OUTLEN>(
  reg ptr u8[OUTLEN] out,
  reg ptr u64[26] state
) -> reg ptr u8[OUTLEN], reg ptr u64[26]
{
  stack u64 rate;

  out = out;
  state = state;
  rate = (1088/8); // = 136

  out, state = __keccak_inc_squeeze<OUTLEN>(out, state, rate);
  return out, state;
}//<>
