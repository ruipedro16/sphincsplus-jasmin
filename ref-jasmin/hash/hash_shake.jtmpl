from Sphincs require "fips202/shake256_array/shake256.jtmpl"
from Sphincs require "fips202/shake256_inc/shake256_inc.jinc" // FIXME: extension should be jtmpl
from Sphincs require "fips202/shake256_out_u64/shake256_out_u64.jtmpl"
from Sphincs require "memcpy/memcpy.jtmpl"
from Sphincs require "generic/utils.jtmpl"

/*
 * Computes PRF(pk_seed, sk_seed, addr)
 */
inline fn __prf_addr(
  reg ptr u8[SPX_N] out,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] addr
) -> reg ptr u8[SPX_N]
{
  stack u8[2*SPX_N + SPX_ADDR_BYTES] buf;
  reg ptr u8[2*SPX_N + SPX_ADDR_BYTES] buf_p;

  reg u64 offset;

  buf_p = buf;
  offset = 0;

  buf_p, offset = _x_memcpy_u8u8<2*SPX_N + SPX_ADDR_BYTES, SPX_N>(buf_p, offset, pub_seed);
  buf_p, offset = _x_memcpy_u8u32<2*SPX_N + SPX_ADDR_BYTES, 8>(buf_p, offset, addr);
  buf_p, offset = _x_memcpy_u8u8<2*SPX_N + SPX_ADDR_BYTES, SPX_N>(buf_p, offset, sk_seed);

  out = __shake256<SPX_N, 2*SPX_N + SPX_ADDR_BYTES>(out, buf_p);
  return out;
}


//// PRF [out is a reg u64 instead of reg ptr u8]
inline fn __prf_addr_out_u64(
  reg u64 out,// reg ptr u8[SPX_N] out,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] addr
)
{
  stack u8[2*SPX_N + SPX_ADDR_BYTES] buf;
  reg ptr u8[2*SPX_N + SPX_ADDR_BYTES] buf_p;

  reg u64 offset;
  inline u64 outlen;

  outlen = SPX_N;

  buf_p = buf;
  offset = 0;

  buf_p, offset = _x_memcpy_u8u8<2*SPX_N + SPX_ADDR_BYTES, SPX_N>(buf_p, offset, pub_seed);
  buf_p, offset = _x_memcpy_u8u32<2*SPX_N + SPX_ADDR_BYTES, 8>(buf_p, offset, addr);
  buf_p, offset = _x_memcpy_u8u8<2*SPX_N + SPX_ADDR_BYTES, SPX_N>(buf_p, offset, sk_seed);

  __shake256_out_u64<2*SPX_N + SPX_ADDR_BYTES>(out, outlen, buf_p);
}

////

inline fn __gen_message_random(
  reg ptr u8[SPX_N] R,
  reg ptr u8[SPX_N] sk_prf,
  reg ptr u8[SPX_N] optrand, // optional randomization value
  reg u64 msg,
  reg u64 msg_len
) -> reg ptr u8[SPX_N]
{
  stack u64[26] shake_state;
  reg ptr u64[26] shake_state_p;

  stack ptr u8[SPX_N] s_R, s_sk_prf, s_optrand;
  stack u64 s_msg s_msg_len;

  // Spill
  s_R = R;
  s_sk_prf = sk_prf;
  s_optrand = optrand;
  s_msg = msg;
  s_msg_len = msg_len;

  shake_state_p = shake_state;

  shake_state_p = __shake256_inc_init_(shake_state_p);

  sk_prf = s_sk_prf;
  shake_state_p = __shake256_inc_absorb_t<SPX_N>(shake_state_p, sk_prf);

  optrand = s_optrand;
  shake_state_p = __shake256_inc_absorb_t<SPX_N>(shake_state_p, optrand);

  msg = s_msg; msg_len = s_msg_len;
  shake_state_p = _shake256_inc_absorb(shake_state_p, msg, msg_len);

  shake_state_p = __shake256_inc_finalize(shake_state_p);

  R = s_R;
  R, _ = __shake256_inc_squeeze_t<SPX_N>(R, shake_state_p);

  return R;
}

/// FIXME: DELETE THIS (ESTA FUNCAOI NAO E USADA: NAO E PRECISOU OUTLENPQ OUTLEN E SPEMRP SPX_N)
inline fn __gen_message_random<OUTLEN>(
  reg ptr u8[OUTLEN] R,
  reg ptr u8[SPX_N] sk_prf,
  reg ptr u8[SPX_N] optrand, // optional randomization value
  reg u64 msg,
  reg u64 msg_len
) -> reg ptr u8[OUTLEN]
{
  stack u64[26] shake_state;
  reg ptr u64[26] shake_state_p;

  stack ptr u8[SPX_N] s_sk_prf, s_optrand;
  stack ptr u8[OUTLEN] s_R;
  stack u64 s_msg s_msg_len;

  // Spill
  s_R = R;
  s_sk_prf = sk_prf;
  s_optrand = optrand;
  s_msg = msg;
  s_msg_len = msg_len;

  shake_state_p = shake_state;

  shake_state_p = __shake256_inc_init_(shake_state_p);

  sk_prf = s_sk_prf;
  shake_state_p = __shake256_inc_absorb_t<SPX_N>(shake_state_p, sk_prf);

  optrand = s_optrand;
  shake_state_p = __shake256_inc_absorb_t<SPX_N>(shake_state_p, optrand);

  msg = s_msg; msg_len = s_msg_len;
  shake_state_p = _shake256_inc_absorb(shake_state_p, msg, msg_len);

  shake_state_p = __shake256_inc_finalize(shake_state_p);

  R = s_R;
  R, _ = __shake256_inc_squeeze_t<OUTLEN>(R, shake_state_p);

  return R;
}//<>

/**
 * Computes the message hash using R, the public key, and the message.
 * Outputs the message digest and the index of the leaf. The index is split in
 * the tree index and the leaf index, for convenient copying to an address.
 * 
 */
inline fn __hash_message<PKLEN>( // FIXME:
  reg ptr u8[SPX_FORS_MSG_BYTES] digest,
  reg u64 tree,
  reg u32 leaf_idx,
  reg ptr u8[SPX_N] R,
  reg ptr u8[PKLEN] pk,
  reg u64 msg msg_len
) -> reg ptr u8[SPX_FORS_MSG_BYTES], reg u64, reg u32
{
  /*
   * buf_p = [ FORS MSG BYTES | TREE BYTES  | LEAF BYTES]
   * 
   */
  
  stack u8[SPX_DGST_BYTES] buf;
  reg ptr u8[SPX_DGST_BYTES] buf_p;

  stack u64[26] shake256_state;
  reg ptr u64[26] shake256_state_p; 

  stack ptr u8[SPX_FORS_MSG_BYTES] s_digest;
  stack u64 s_tree s_msg s_msg_len;
  stack u32 s_leaf_idx;
  stack ptr u8[PKLEN] s_pk;

  reg u64 offset;
  reg u64 t u;

  reg ptr u8[SPX_TREE_BYTES] tree_bytes;
  reg ptr u8[SPX_LEAF_BYTES] leaf_bytes;
 
  shake256_state_p = shake256_state;

  shake256_state_p = __shake256_inc_init_(shake256_state_p);

  // Spill
  s_digest = digest; 
  s_tree = tree; 
  s_leaf_idx = leaf_idx; 
  s_pk = pk; 
  s_msg = msg;
  s_msg_len = msg_len;

  shake256_state_p = __shake256_inc_absorb_t<SPX_N>(shake256_state_p, R);

  pk = s_pk;
  shake256_state_p = __shake256_inc_absorb_t<PKLEN>(shake256_state_p, pk);

  msg = s_msg;
  msg_len = s_msg_len;
  shake256_state_p = _shake256_inc_absorb(shake256_state_p, msg, msg_len);

  shake256_state_p = __shake256_inc_finalize(shake256_state_p);

  buf_p = buf;
  buf_p, _ = __shake256_inc_squeeze_t<SPX_DGST_BYTES>(buf_p, shake256_state_p);

  offset = 0;
  digest = s_digest;
  digest, _ = __memcpy_u8u8<SPX_FORS_MSG_BYTES, SPX_DGST_BYTES>(digest, offset, buf_p);

  tree_bytes = buf[SPX_FORS_MSG_BYTES:SPX_TREE_BYTES];
  tree = __bytes_to_ull<SPX_TREE_BYTES>(tree, tree_bytes);
  ?{}, t = #set0(); 
  t = #NOT_64(t);
  u = 64;
  u -= SPX_TREE_BITS;
  ?{}, t = #SHR(t, u);
  tree &= t;
  
  leaf_bytes = buf[SPX_FORS_MSG_BYTES + SPX_TREE_BYTES : SPX_LEAF_BYTES];
  t = __bytes_to_ull<SPX_LEAF_BYTES>(t, leaf_bytes);
  leaf_idx = (32u) t;
  t = 0; 
  t = #NOT_64(t);
  u = 32;
  u -= SPX_LEAF_BITS;
  ?{}, t = #SHR(t, u);
  leaf_idx &= (32u) t;

  return digest, tree, leaf_idx;
}//<>

#[returnaddress="stack"]
fn _hash_message<PKLEN>( // FIXME:
  reg ptr u8[SPX_FORS_MSG_BYTES] digest,
  reg u64 tree,
  reg u32 leaf_idx,
  reg ptr u8[SPX_N] R,
  reg ptr u8[PKLEN] pk,
  reg u64 msg,
  reg u64 msg_len
) -> reg ptr u8[SPX_FORS_MSG_BYTES], 
     reg u64, 
     reg u32
{
  digest, tree, leaf_idx = __hash_message<PKLEN>(digest, tree, leaf_idx, R, pk, msg, msg_len);
  return digest, tree, leaf_idx;
}//<>