from Sphincs require "fips202/shake256.jtmpl"
from Sphincs require "fips202/shake256_inc.jtmpl"
from Sphincs require "memcpy/memcpy.jtmpl"

inline fn __bytes_to_ull<INLEN>(
  reg ptr u8[INLEN] in
) -> reg u64
{
  reg u64 retval;
  reg u64 t u;
  inline int i;

  retval = 0;
  for i = 0 to INLEN {
    t = INLEN;
    t -= 1;
    t -= i;
    t <<= 3; // Same as t *= 8;
    u = (64u) in[i];
    u <<= (t & 63);
    retval |= u;
  }
  return retval;
}//<>

/*
 * Computes PRF(pk_seed, sk_seed, addr)
 */
inline fn __prf_addr(
  reg ptr u8[SPX_N] out,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] addr
) -> reg ptr u8[SPX_N]
{
  stack u8[2*SPX_N + SPX_ADDR_BYTES] buf;
  reg ptr u8[2*SPX_N + SPX_ADDR_BYTES] buf_p;

  reg u64 offset;
  stack u64 s_offset;

  buf_p = buf;
  offset = 0;

  buf_p, offset = _x_memcpy_u8u8<2*SPX_N + SPX_ADDR_BYTES, SPX_N>(buf_p, offset, pub_seed);
  buf_p, offset = _x_memcpy_u8u32<2*SPX_N + SPX_ADDR_BYTES, 8>(buf_p, offset, addr);
  buf_p, offset = _x_memcpy_u8u8<2*SPX_N + SPX_ADDR_BYTES, SPX_N>(buf_p, offset, sk_seed);

  s_offset = offset;

  out = __shake256<SPX_N, 2*SPX_N + SPX_ADDR_BYTES>(out, buf_p);
  return out;
}

/*
 * Computes the message-dependent randomness R, using a secret seed and an
 * optional randomization value as well as the message
 * MSG_LEN is the message length
 */
inline fn __gen_message_random<MSG_LEN>(
  reg ptr u8[SPX_N] R,
  reg ptr u8[SPX_N] sk_prf,
  reg ptr u8[SPX_N] optrand, // optional randomization value
  reg ptr u8[MSG_LEN] m
) -> reg ptr u8[SPX_N]
{
  stack u64[26] shake256_state;
  reg ptr u64[26] shake256_state_p;

  shake256_state_p = shake256_state;


  shake256_state_p = __shake256_inc_init(shake256_state_p);
  shake256_state_p = __shake256_inc_absorb<SPX_N>(shake256_state_p, sk_prf);
  shake256_state_p = __shake256_inc_absorb<SPX_N>(shake256_state_p, optrand);
  shake256_state_p = __shake256_inc_absorb<MSG_LEN>(shake256_state_p, m);
  shake256_state_p = __shake256_inc_finalize(shake256_state_p);
  R, _ = __shake256_inc_squeeze<SPX_N>(R, shake256_state_p);

  return R;
}//<>

/**
 * Computes the message hash using R, the public key, and the message.
 * Outputs the message digest and the index of the leaf. The index is split in
 * the tree index and the leaf index, for convenient copying to an address.
 * 
 */
inline fn __hash_message<MSG_LEN>(
  reg ptr u8[SPX_FORS_MSG_BYTES] digest,
  reg u64 tree,
  reg u32 leaf_idx,
  reg ptr u8[SPX_N] R,
  reg ptr u8[SPX_PK_BYTES] pk,
  reg ptr u8[MSG_LEN] m
) -> reg ptr u8[SPX_FORS_MSG_BYTES], reg u64, reg u32
{
  /*
   * buf_p = [ FORS MSG BYTES | TREE BYTES  | LEAF BYTES]
   * 
   */
  stack u8[SPX_DGST_BYTES] buf;
  reg ptr u8[SPX_DGST_BYTES] buf_p;
  reg ptr u8[SPX_TREE_BYTES] buf_tree_p;
  reg ptr u8[SPX_LEAF_BYTES] buf_leaf_p;

  stack u64[26] shake256_state;
  reg ptr u64[26] shake256_state_p; 

  reg u64 t u;
  reg u32 z;

  buf_p = buf;
  shake256_state_p = shake256_state;

  shake256_state_p = __shake256_inc_init(shake256_state_p);
  shake256_state_p = __shake256_inc_absorb<SPX_N>(shake256_state_p, R);
  shake256_state_p = __shake256_inc_absorb<SPX_PK_BYTES>(shake256_state_p, pk);
  shake256_state_p = __shake256_inc_absorb<MSG_LEN>(shake256_state_p, m);
  shake256_state_p = __shake256_inc_finalize(shake256_state_p);
  buf_p, _ = __shake256_inc_squeeze<SPX_DGST_BYTES>(buf_p, shake256_state_p);

  t = 0; // offset
  digest, _ = __memcpy_u8u8<SPX_FORS_MSG_BYTES,SPX_DGST_BYTES>(digest, t, buf_p);

  // Tree
  buf_tree_p = buf[SPX_FORS_MSG_BYTES : SPX_TREE_BYTES];
  tree = __bytes_to_ull<SPX_TREE_BYTES>(buf_tree_p);
  t = !0;
  u = 64;
  u -= SPX_TREE_BITS;
  t >>= (u & 63);
  tree &= t;

  // Leaf
  buf_leaf_p = buf[SPX_FORS_MSG_BYTES + SPX_TREE_BYTES : SPX_LEAF_BYTES]; 
  t = __bytes_to_ull<SPX_LEAF_BYTES>(buf_leaf_p);
  leaf_idx = (32u)t;
  t = !0;
  u = 32;
  u -= SPX_LEAF_BITS;
  t >>= (u & 63);
  leaf_idx &= (32u)t;

  return digest, tree, leaf_idx;
}//<>

