from Sphincs require "fips202/shake256.jtmpl"
from Sphincs require "fips202/shake256_inc.jtmpl"
from Sphincs require "memcpy/memcpy.jtmpl"
from Sphincs require "generic/utils.jtmpl"

/*
 * Computes PRF(pk_seed, sk_seed, addr)
 */
inline fn __prf_addr(
  reg ptr u8[SPX_N] out,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] addr
) -> reg ptr u8[SPX_N]
{
  stack u8[2*SPX_N + SPX_ADDR_BYTES] buf;
  reg ptr u8[2*SPX_N + SPX_ADDR_BYTES] buf_p;

  reg u64 offset;
  stack u64 s_offset;

  buf_p = buf;
  offset = 0;

  buf_p, offset = _x_memcpy_u8u8<2*SPX_N + SPX_ADDR_BYTES, SPX_N>(buf_p, offset, pub_seed);
  buf_p, offset = _x_memcpy_u8u32<2*SPX_N + SPX_ADDR_BYTES, 8>(buf_p, offset, addr);
  buf_p, offset = _x_memcpy_u8u8<2*SPX_N + SPX_ADDR_BYTES, SPX_N>(buf_p, offset, sk_seed);

  s_offset = offset;

  out = __shake256<SPX_N, 2*SPX_N + SPX_ADDR_BYTES>(out, buf_p);
  return out;
}

/*
 * Computes the message-dependent randomness R, using a secret seed and an
 * optional randomization value as well as the message
 * MSG_LEN is the message length
 */
inline fn __gen_message_random<MSG_LEN>(
  reg ptr u8[SPX_N] R,
  reg ptr u8[SPX_N] sk_prf,
  reg ptr u8[SPX_N] optrand, // optional randomization value
  reg ptr u8[MSG_LEN] m
) -> reg ptr u8[SPX_N]
{
  stack u64[26] shake256_state;
  reg ptr u64[26] shake256_state_p;

  stack ptr u8[SPX_N] s_R;
  stack ptr u8[SPX_N] s_sk_prf;
  stack ptr u8[SPX_N] s_optrand;
  stack ptr u8[MSG_LEN] s_m;

  shake256_state_p = shake256_state;

  shake256_state_p = __shake256_inc_init_(shake256_state_p);

  s_R = R; s_optrand = optrand; s_m = m; // spill
  shake256_state_p = __shake256_inc_absorb_<SPX_N>(shake256_state_p, sk_prf);
  s_sk_prf = sk_prf; // spill

  optrand = s_optrand; // unspill
  shake256_state_p = __shake256_inc_absorb_<SPX_N>(shake256_state_p, optrand);
  s_optrand = optrand; // spill

  m = s_m; // unspill
  shake256_state_p = __shake256_inc_absorb_<MSG_LEN>(shake256_state_p, m);
  s_m = m; // spill

  shake256_state_p = __shake256_inc_finalize(shake256_state_p);

  R = s_R; // unspill
  R, _ = __shake256_inc_squeeze<SPX_N>(R, shake256_state_p);

  return R;
}//<>

/**
 * Computes the message hash using R, the public key, and the message.
 * Outputs the message digest and the index of the leaf. The index is split in
 * the tree index and the leaf index, for convenient copying to an address.
 * 
 */
inline fn __hash_message<MSG_LEN>(
  reg ptr u8[SPX_FORS_MSG_BYTES] digest,
  reg u64 tree,
  reg u32 leaf_idx,
  reg ptr u8[SPX_N] R,
  reg ptr u8[SPX_PK_BYTES] pk,
  reg ptr u8[MSG_LEN] m
) -> reg ptr u8[SPX_FORS_MSG_BYTES], reg u64, reg u32
{
  /*
   * buf_p = [ FORS MSG BYTES | TREE BYTES  | LEAF BYTES]
   * 
   */
  stack u8[SPX_DGST_BYTES] buf;
  reg ptr u8[SPX_DGST_BYTES] buf_p;
  reg ptr u8[SPX_TREE_BYTES] buf_tree_p;
  reg ptr u8[SPX_LEAF_BYTES] buf_leaf_p;

  stack u64[26] shake256_state;
  reg ptr u64[26] shake256_state_p; 

  stack ptr u8[SPX_FORS_MSG_BYTES] s_digest;
  stack u64 s_tree;
  stack u32 s_leaf_idx;
  stack ptr u8[SPX_N] s_R;
  stack ptr u8[SPX_PK_BYTES] s_pk;
  stack ptr u8[MSG_LEN] s_m;

  reg u64 t u;
  reg u32 z;

  shake256_state_p = shake256_state;

  shake256_state_p = __shake256_inc_init_(shake256_state_p);

  s_digest = digest; s_tree = tree; s_leaf_idx = leaf_idx; s_pk = pk; s_m = m; // spill
  shake256_state_p = __shake256_inc_absorb_<SPX_N>(shake256_state_p, R);
  s_R = R;

  pk = s_pk;
  shake256_state_p = __shake256_inc_absorb_<SPX_PK_BYTES>(shake256_state_p, pk);
  s_pk = pk;

  m = s_m;
  shake256_state_p = __shake256_inc_absorb<MSG_LEN>(shake256_state_p, m);
  s_m = m;

  shake256_state_p = __shake256_inc_finalize(shake256_state_p);

  buf_p = buf;
  buf_p, _ = __shake256_inc_squeeze<SPX_DGST_BYTES>(buf_p, shake256_state_p);
  shake256_state = shake256_state_p;

  t = 0; // offset
  digest = s_digest;
  digest, _ = __memcpy_u8u8<SPX_FORS_MSG_BYTES,SPX_DGST_BYTES>(digest, t, buf_p);

  tree = s_tree;
  leaf_idx = s_leaf_idx;

  // Tree
  buf_tree_p = buf[SPX_FORS_MSG_BYTES : SPX_TREE_BYTES];
  tree = __bytes_to_ull<SPX_TREE_BYTES>(tree, buf_tree_p);
  t = !0;
  u = 64;
  u -= SPX_TREE_BITS;
  t >>= (u & 63);
  tree &= t;

  // Leaf
  buf_leaf_p = buf[SPX_FORS_MSG_BYTES + SPX_TREE_BYTES : SPX_LEAF_BYTES]; 
  t = __bytes_to_ull<SPX_LEAF_BYTES>(t, buf_leaf_p);
  leaf_idx = (32u)t;
  t = !0;
  u = 32;
  u -= SPX_LEAF_BITS;
  t >>= (u & 63);
  leaf_idx &= (32u)t;

  return digest, tree, leaf_idx;
}//<>
