from Sphincs require "fips202/shake256.jtmpl"
from Sphincs require "memcpy/memcpy.jtmpl"

/*
 * TODO: FIXME: These parameters are not ints
 */
param int SPX_TREE_BITS = 7;
param int SPX_TREE_BYTES = 15;
param int SPX_LEAF_BITS = SPX_TREE_HEIGHT;
param int SPX_LEAF_BYTES = 8;
param int SPX_DGST_BYTES = SPX_FORS_MSG_BYTES + SPX_TREE_BYTES + SPX_LEAF_BYTES;

/*
 * TODO: Doesnt compile
 * linearization: check_rexpr
 */
inline fn __bytes_to_ull<INLEN>(
  reg ptr u8[INLEN] in
) -> reg u64
{
  reg u64 retval;
  reg u64 t;
  inline int i;

  retval = 0;
  /*
  for i = 0 to INLEN {
    t = (64u) in[i];
    t <<  = (8*(INLEN - 1 - i));
    retval |= (64u) t;
  }
  */
  return retval;
}//<>

/*
 * Computes PRF(pk_seed, sk_seed, addr)
 */
inline fn __prf_addr(
  reg ptr u8[SPX_N] out,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] addr
) -> reg ptr u8[SPX_N]
{
  stack u8[2*SPX_N + SPX_ADDR_BYTES] buf;
  reg ptr u8[2*SPX_N + SPX_ADDR_BYTES] buf_p;

  reg u64 offset;
  stack u64 s_offset;

  buf_p = buf;
  offset = 0;

  buf_p, offset = _x_memcpy_u8u8<2*SPX_N + SPX_ADDR_BYTES, SPX_N>(buf_p, offset, pub_seed);
  buf_p, offset = _x_memcpy_u8u32<2*SPX_N + SPX_ADDR_BYTES, 8>(buf_p, offset, addr);
  buf_p, offset = _x_memcpy_u8u8<2*SPX_N + SPX_ADDR_BYTES, SPX_N>(buf_p, offset, sk_seed);

  s_offset = offset;

  out = __shake256<SPX_N, 2*SPX_N + SPX_ADDR_BYTES>(out, buf_p);
  return out;
}

/*
 * Computes the message-dependent randomness R, using a secret seed and an
 * optional randomization value as well as the message
 * MSG_LEN is the message length
 *
 * TODO: The result is wrong
 */
inline fn __gen_message_random<MSG_LEN>(
  reg ptr u8[SPX_N] R,
  reg ptr u8[SPX_N] sk_prf,
  reg ptr u8[SPX_N] optrand, // optional randomization value
  reg ptr u8[MSG_LEN] m
) -> reg ptr u8[SPX_N]
{
  stack u8[2 * SPX_N + MSG_LEN] buf;
  reg ptr u8 [2 * SPX_N + MSG_LEN] buf_p;

  reg u64 offset;

  buf_p  = buf;
  offset = 0;  
  
  buf_p, offset = _x_memcpy_u8u8<2 * SPX_N + MSG_LEN, SPX_N>(buf_p, offset, sk_prf);  // copy sk_prf into buf
  buf_p, offset = _x_memcpy_u8u8<2 * SPX_N + MSG_LEN, SPX_N>(buf_p, offset, optrand); // copy optrand into buf
  buf_p, _      = _x_memcpy_u8u8<2 * SPX_N + MSG_LEN, MSG_LEN>(buf_p, offset, m);     // copy m into buf 

  R = __shake256<SPX_N, 2 * SPX_N + MSG_LEN>(R, buf_p);
  buf_p = buf;

  return R;
}//<>

/**
 * Computes the message hash using R, the public key, and the message.
 * Outputs the message digest and the index of the leaf. The index is split in
 * the tree index and the leaf index, for convenient copying to an address.
 *
 * TODO: The result is wrong
 *       SPX_DGST_BYTES is not an integer
 * 
 */
inline fn __hash_message<MSG_LEN>(
  reg ptr u8[SPX_DGST_BYTES] digest,
  reg u64 tree,
  reg u32 leaf_idx,
  reg ptr u8[SPX_N] R,
  reg ptr u8[SPX_PK_BYTES] pk,
  reg ptr u8[MSG_LEN] m
) -> reg ptr u8[SPX_DGST_BYTES], reg u64, reg u32
{
  ////////////// to spill regs
  stack u8[SPX_DGST_BYTES] digest_s;
  stack u64 tree_s;
  stack u32 leaf_idx_s;
  stack ptr u8[SPX_N] R_s;
  stack ptr u8[SPX_PK_BYTES] pk_s;
  stack ptr u8[MSG_LEN] m_s;

  ///////////////////////////////////

  stack u8[SPX_N + SPX_PK_BYTES + MSG_LEN]   tmp;     // holds the data to hash
  reg ptr u8[SPX_N + SPX_PK_BYTES + MSG_LEN] tmp_p;   // holds the data to hash

  reg u64 offset;

  // Data to hash
  tmp_p = tmp; offset = 0;
  tmp_p, offset = _x_memcpy_u8u8<SPX_N + SPX_PK_BYTES + MSG_LEN, SPX_N>(tmp_p, offset, R);        // copy R into tmp
  R_s = R;

  tmp_p, offset = _x_memcpy_u8u8<SPX_N + SPX_PK_BYTES + MSG_LEN, SPX_PK_BYTES>(tmp_p, offset, pk); // copy pk into tmp
  pk_s = pk;

  tmp_p, _      = _x_memcpy_u8u8<SPX_N + SPX_PK_BYTES + MSG_LEN, MSG_LEN>(tmp_p, offset, m);      // copy m into tmp
  m_s = m;

  // Spills
  tree_s = tree; 
  leaf_idx_s = leaf_idx;
  digest_s = digest;

  stack u8[SPX_DGST_BYTES]   buf;
  reg ptr u8[SPX_DGST_BYTES] buf_p;

  // Hash and output the result to buf
  // buf_p = buf;
  // buf_p = __shake256<SPX_DGST_BYTES, SPX_N + SPX_PK_BYTES + MSG_LEN>(buf_p, tmp_p);
  // tmp_p = tmp; buf = buf_p;

  stack u8[SPX_TREE_BYTES] tree_bytes;
  reg ptr u8[SPX_TREE_BYTES] tree_bytes_p;
  tree_bytes_p = tree_bytes;

  tree = __bytes_to_ull<SPX_TREE_BYTES>(tree_bytes_p); 
  tree_bytes = tree_bytes_p;  
  // tree &= !0 >> (64 - SPX_TREE_BITS);


  // unspill
  leaf_idx = leaf_idx_s;
  digest = digest_s;
  return digest, tree, leaf_idx;
}//<>
