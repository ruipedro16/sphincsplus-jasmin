from Sphincs require "hash/hash_shake.jtmpl"
from Sphincs require "fors/fors.jtmpl"
from Sphincs require "memcmp/memcmp.jtmpl"
from Sphincs require "memset/memset.jinc"
from Sphincs require "merkle/merkle.jtmpl"

//////////////////////// SIGN SEED KEYPAIR

#[returnaddress="stack"]
fn _crypto_sign_seed_keypair(
  reg ptr u8[SPX_PK_BYTES] pk,
  reg ptr u8[SPX_SK_BYTES] sk,
  reg ptr u8[CRYPTO_SEEDBYTES] seed
) -> reg ptr u8[SPX_PK_BYTES],
     reg ptr u8[SPX_SK_BYTES]
{
  ////
  stack ptr u8[SPX_PK_BYTES] s_pk;
  stack ptr u8[SPX_SK_BYTES] s_sk;
  ////

  stack u8[SPX_N] pub_seed;
  stack u8[SPX_N] sk_seed;

  reg ptr u8[SPX_N] pub_seed_p;
  reg ptr u8[SPX_N] sk_seed_p;

  reg ptr u8[SPX_N] root;
  reg ptr u8[SPX_N] buf;
  reg u64 offset;

  // Initialize SK_SEED, SK_PRF and PUB_SEED from seed

  // memcpy(sk, seed, CRYPTO_SEEDBYTES);
  offset = 0;
  sk, _ = _x_memcpy_u8u8<SPX_SK_BYTES, CRYPTO_SEEDBYTES>(sk, offset, seed);

  // memcpy(pk, sk + 2 * SPX_N, SPX_N);
  offset = 0;
  buf = sk[2 * SPX_N : SPX_N];
  pk, _ = _x_memcpy_u8u8<SPX_PK_BYTES, SPX_N>(pk, offset, buf);

  // memcpy(ctx.pub_seed, pk, SPX_N);
  pub_seed_p = pub_seed;
  offset = 0;
  buf = pk[0 : SPX_N];
  pub_seed_p, _ = _x_memcpy_u8u8<SPX_N, SPX_N>(pub_seed_p, offset, buf);
  pub_seed = pub_seed_p;

  // memcpy(ctx.sk_seed, sk, SPX_N);
  sk_seed_p = sk_seed;
  offset = 0;
  buf = sk[0 : SPX_N];
  sk_seed_p, _ = _x_memcpy_u8u8<SPX_N, SPX_N>(sk_seed_p, offset, buf);
  sk_seed = sk_seed_p;

  s_pk = pk; // spills
  s_sk = sk; // spills

  // merkle_gen_root(sk + 3 * SPX_N, &ctx);
  sk = s_sk;
  root = sk[3*SPX_N : SPX_N];
  pub_seed_p = pub_seed;
  sk_seed_p = sk_seed;
  sk[3*SPX_N : SPX_N] = _merkle_gen_root(root, pub_seed_p, sk_seed_p);
  s_sk = sk;

  // memcpy(pk + SPX_N, sk + 3 * SPX_N, SPX_N);  
  offset = SPX_N;
  buf = sk[3*SPX_N : SPX_N];
  pk = s_pk; // unspill
  pk, _ = _x_memcpy_u8u8<SPX_PK_BYTES, SPX_N>(pk, offset, buf);

  sk = s_sk; // unspill

  return pk, sk;
}

inline fn __crypto_sign_seed_keypair(reg u64 _pk _sk _seed) -> reg u64
{
  reg u64 r;

  stack u8[SPX_PK_BYTES] pk;
  reg ptr u8[SPX_PK_BYTES] pk_p;

  stack u8[SPX_SK_BYTES] sk;
  reg ptr u8[SPX_SK_BYTES] sk_p;

  stack u8[CRYPTO_SEEDBYTES] seed;
  reg ptr u8[CRYPTO_SEEDBYTES] seed_p;

  reg u64 offset inlen;

  stack u64 s_pk s_sk;

  // FIXME: TODO: REMOVE THIS WHEN GEN ROOT IS IMPLEMENTED CORRECTLY
  sk = __load_u8_array<SPX_SK_BYTES>(sk, _sk);
  pk = __load_u8_array<SPX_PK_BYTES>(pk, _pk);

  s_pk = _pk; // spill 
  s_sk = _sk; // spill

  // load seed
  seed_p = seed;
  offset = 0;
  inlen = CRYPTO_SEEDBYTES;
  seed_p, _ = _x_memcpy_u8u8p<CRYPTO_SEEDBYTES>(seed_p, offset, _seed, inlen);

  pk_p = pk;
  sk_p = sk;

  pk_p, sk_p = _crypto_sign_seed_keypair(pk_p, sk_p, seed_p);

  _pk = s_pk; // unspill 
  _sk = s_sk; // unspill

  __store_u8_array<SPX_PK_BYTES>(pk_p, _pk);
  __store_u8_array<SPX_SK_BYTES>(sk_p, _sk);

  ?{}, r = #set0();
  return r;
}

//////////////////////// SIGN KEYPAIR
inline fn __crypto_sign_keypair(reg u64 _pk _sk) -> reg u64
{
  reg u64 r;

  stack u8[SPX_PK_BYTES] pk;
  reg ptr u8[SPX_PK_BYTES] pk_p;

  stack u8[SPX_SK_BYTES] sk;
  reg ptr u8[SPX_SK_BYTES] sk_p;

  stack u8[CRYPTO_SEEDBYTES] seed;
  reg ptr u8[CRYPTO_SEEDBYTES] seed_p;

  stack u64 s_pk s_sk;

  s_pk = _pk; // spill
  s_sk = _sk; // spill 

  seed_p = seed;
  seed_p = #randombytes(seed_p);

  pk_p = pk;
  sk_p = sk;
  pk_p, sk_p = _crypto_sign_seed_keypair(pk_p, sk_p, seed_p);

  _pk = s_pk; // unspill 
  _sk = s_sk; // unspill

  __store_u8_array<SPX_PK_BYTES>(pk_p, _pk);
  __store_u8_array<SPX_SK_BYTES>(sk_p, _sk);

  ?{}, r = #set0();
  return r;
}
