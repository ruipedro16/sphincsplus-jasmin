from Sphincs require "address/address.jinc"
from Sphincs require "memcpy/memcpy.jtmpl"
from Sphincs require "memcmp/memcmp.jtmpl"
from Sphincs require "merkle/merkle.jtmpl"
from Sphincs require "generic/utils.jtmpl"
from Sphincs require "hash/hash_shake.jtmpl"
from Sphincs require "fors/fors.jtmpl"

/*
 * Generates an SPX key pair given a seed of length
 * Format sk: [SK_SEED || SK_PRF || PUB_SEED || root]
 * Format pk: [PUB_SEED || root]
 */
inline fn __crypto_sign_seed_keypair(
  reg ptr u8[SPX_PK_BYTES] pk,
  reg ptr u8[SPX_SK_BYTES] sk,
  reg ptr u8[CRYPTO_SEEDBYTES] seed
) -> reg ptr u8[SPX_PK_BYTES], reg ptr u8[SPX_SK_BYTES]
{
  stack u8[SPX_N] pub_seed;
  stack u8[SPX_N] sk_seed;

  reg u64 offset;

  inline int i; 
  reg u8 t; 
  stack u8 s_t;

  reg ptr u8[SPX_N] root;

  offset = 0;
  sk, offset = _x_memcpy_u8u8<SPX_SK_BYTES, CRYPTO_SEEDBYTES>(sk, offset, seed);
  
  for i=0 to SPX_N { 
    t = sk[2*SPX_N + i]; 
    pk[i]=t; 
  }

  s_t = t;

  offset = 0;
  pub_seed, offset = _x_memcpy_u8u8<SPX_N, SPX_PK_BYTES>(pub_seed, offset, pk);

  offset = 0;
  sk_seed, offset = _x_memcpy_u8u8<SPX_N, SPX_SK_BYTES>(sk_seed, offset, sk);

  root = sk[3*SPX_N : SPX_N];
  root = __merkle_gen_root(root, pub_seed, sk_seed);
  sk[3*SPX_N : SPX_N] = root;

  for i=0 to SPX_N { 
    t = sk[3*SPX_N + i]; 
    pk[SPX_N + i]=t; 
  }

  return pk, sk;
}

/*
 * Generates an SPX key pair.
 * Format sk: [SK_SEED || SK_PRF || PUB_SEED || root]
 * Format pk: [PUB_SEED || root]
 */
inline fn __crypto_sign_keypair(
  reg ptr u8[SPX_PK_BYTES] pk,
  reg ptr u8[SPX_SK_BYTES] sk
) -> reg ptr u8[SPX_PK_BYTES], reg ptr u8[SPX_SK_BYTES]
{
  stack u8[CRYPTO_SEEDBYTES] seed;
  reg ptr u8[CRYPTO_SEEDBYTES] seed_p;

  seed_p = seed;
  seed_p = #randombytes(seed_p);
  
  pk, sk = __crypto_sign_seed_keypair(pk, sk, seed_p);
  return pk, sk;
}
