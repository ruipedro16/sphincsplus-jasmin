from Sphincs require "hash/hash_shake.jtmpl"
from Sphincs require "fors/fors.jtmpl"
from Sphincs require "memcmp/memcmp.jtmpl"
from Sphincs require "memset/memset.jinc"
from Sphincs require "merkle/merkle.jtmpl"

inline fn __crypto_sign_seed_keypair(
  reg ptr u8[SPX_PK_BYTES] pk,
  reg ptr u8[SPX_SK_BYTES] sk,
  reg ptr u8[CRYPTO_SEEDBYTES] seed
) -> reg ptr u8[SPX_PK_BYTES], 
     reg ptr u8[SPX_SK_BYTES]
{
  stack u8[SPX_N] pub_seed;
  stack u8[SPX_N] sk_seed;

  reg ptr u8[SPX_N] pub_seed_p;
  reg ptr u8[SPX_N] sk_seed_p;

  reg ptr u8[SPX_N] root;

  reg ptr u8[SPX_N] buf;

  reg u64 offset;

  reg u8 t;

  inline int i;

  pub_seed_p = pub_seed;
  sk_seed_p  = sk_seed;

  // memcpy(sk, seed, CRYPTO_SEEDBYTES);
  offset = 0;
  sk, _ = _x_memcpy_u8u8<SPX_SK_BYTES, CRYPTO_SEEDBYTES>(sk, offset, seed);

  // memcpy(pk, sk + 2 * SPX_N, SPX_N);
  offset = 0;
  buf = sk[2 * SPX_N : SPX_N];
  pk, _ = _x_memcpy_u8u8<SPX_PK_BYTES, SPX_N>(pk, offset, buf);

  // memcpy(ctx.pub_seed, pk, SPX_N);
  offset = 0;
  buf = pk[0:SPX_N];
  pub_seed_p, _ = _x_memcpy_u8u8<SPX_N, SPX_N>(pub_seed_p, offset, buf);

  // memcpy(ctx.sk_seed, sk, SPX_N);
  offset = 0;
  buf = sk[0:SPX_N];
  sk_seed_p, _ = _x_memcpy_u8u8<SPX_N, SPX_N>(sk_seed_p, offset, buf);

  // merkle_gen_root(sk + 3 * SPX_N, &ctx);
  root = sk[3*SPX_N : SPX_N];
  pub_seed_p = pub_seed;
  sk_seed_p = sk_seed;
  root = __merkle_gen_root(root, pub_seed_p, sk_seed_p);
  sk[3*SPX_N : SPX_N] = root;

  // memcpy(pk + SPX_N, sk + 3 * SPX_N, SPX_N);  
  for i=0 to SPX_N
  { 
    t = sk[3*SPX_N + i]; 
    pk[SPX_N +  i] = t; 
  }

  return pk, sk;
}

#[returnaddress="stack"]
fn _crypto_sign_seed_keypair(
  reg ptr u8[SPX_PK_BYTES] pk,
  reg ptr u8[SPX_SK_BYTES] sk,
  reg ptr u8[CRYPTO_SEEDBYTES] seed
) -> reg ptr u8[SPX_PK_BYTES], 
     reg ptr u8[SPX_SK_BYTES]
{
  pk, sk = __crypto_sign_seed_keypair(pk, sk, seed);
  return pk, sk;
}


#[returnaddress="stack"]
fn _crypto_sign_keypair(
  reg ptr u8[SPX_PK_BYTES] pk,
  reg ptr u8[SPX_SK_BYTES] sk
) -> reg ptr u8[SPX_PK_BYTES], 
     reg ptr u8[SPX_SK_BYTES]
{
  stack u8[CRYPTO_SEEDBYTES] seed;
  reg ptr u8[CRYPTO_SEEDBYTES] seed_p;

  seed_p = seed;
  seed_p = #randombytes(seed_p);

  pk, sk = __crypto_sign_seed_keypair(pk, sk, seed_p);

  return pk, sk;
}

inline fn __crypto_sign_signature(
  reg u64 sig,
  reg u64 msg,
  reg u64 msg_len,
  reg ptr u8[SPX_SK_BYTES] sk
)
{
  /////// Variables for spills
  stack u64 s_sig;
  stack u64 s_msg;
  stack u64 s_msg_len;
  stack ptr u8[SPX_SK_BYTES] s_sk;
  ///////

  stack u8[SPX_N] pub_seed;
  reg ptr u8[SPX_N] pub_seed_p; 

  stack u8[SPX_N] sk_seed;
  reg ptr u8[SPX_N] sk_seed_p;

  reg ptr u8[SPX_N] sk_prf;
  stack ptr u8[SPX_N] s_sk_prf;

  reg ptr u8[SPX_N] pk;
  stack ptr u8[SPX_N] s_pk;

  stack u8[SPX_N] optrand;
  reg ptr u8[SPX_N] optrand_p;

  stack u8[SPX_N] randomness;
  reg ptr u8[SPX_N] randomness_p;

  stack u8[SPX_FORS_MSG_BYTES] mhash;
  reg ptr u8[SPX_FORS_MSG_BYTES] mhash_p;
  
  stack u8[SPX_N] root;
  reg ptr u8[SPX_N] root_p;

  stack u32[8] wots_addr;
  reg ptr u32[8] wots_addr_p;

  stack u32[8] tree_addr;
  reg ptr u32[8] tree_addr_p;

  reg u32 idx_leaf; 
  stack u32 s_idx_leaf;

  reg u64 tree; 
  stack u64 s_tree;

  reg u64 offset;
  reg u32 type;

  reg ptr u8[SPX_N] buf;

  reg u32 i;
  stack u32 s_i;

  inline int k;
  reg u32 t;

  stack u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] auth_path; // FIXME: Fazer _merkle_sign com um reg 64 em vez de reg ptr
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] auth_path_p;

  ///////////// initial spills
  s_sig = sig;
  s_msg = msg;
  s_msg_len = msg_len;
  s_sk = sk;
  /////////////

  // const unsigned char *sk_prf = sk + SPX_N;
  sk_prf = sk[SPX_N : SPX_N];
  s_sk_prf = sk_prf;

  // const unsigned char *pk = sk + 2 * SPX_N;
  pk = sk[2*SPX_N : SPX_N];  
  s_pk = pk;

  // uint32_t wots_addr[8] = {0};
  wots_addr_p = wots_addr;
  wots_addr = __zero_array_u32<8>(wots_addr);
  wots_addr = wots_addr_p;

  // uint32_t tree_addr[8] = {0};
  tree_addr_p = tree_addr;
  tree_addr = __zero_array_u32<8>(tree_addr);
  tree_addr = tree_addr_p;

  // memcpy(ctx.sk_seed, sk, SPX_N);
  offset = 0;
  buf = sk[0:SPX_N];
  sk_seed_p = sk_seed;
  sk_seed_p, _ = _x_memcpy_u8u8<SPX_N, SPX_N>(sk_seed_p, offset, buf);
  sk_seed = sk_seed_p;

  // memcpy(ctx.pub_seed, pk, SPX_N);
  offset = 0;
  buf = pk[0:SPX_N];
  pub_seed_p = pub_seed;
  pub_seed_p, _ = _x_memcpy_u8u8<SPX_N, SPX_N>(pub_seed_p, offset, buf);
  pub_seed = pub_seed_p;


  // set_type(wots_addr, SPX_ADDR_TYPE_WOTS);
  type = SPX_ADDR_TYPE_WOTS;
  wots_addr_p = wots_addr;
  wots_addr_p = __set_type(wots_addr_p, type);

  // set_type(tree_addr, SPX_ADDR_TYPE_HASHTREE);
  type = SPX_ADDR_TYPE_HASHTREE;
  tree_addr_p = tree_addr;
  tree_addr_p = __set_type(tree_addr_p, type);

  wots_addr = wots_addr_p;
  tree_addr = tree_addr_p;

  // randombytes(optrand, SPX_N);
  optrand_p = optrand;
  optrand_p = #randombytes(optrand_p);

  // gen_message_random(sig, sk_prf, optrand, m, mlen, &ctx);
    randomness_p = randomness;
    msg = s_msg;
    msg_len = s_msg_len;
    sk_prf = s_sk_prf;
  randomness_p = __gen_message_random(randomness_p, sk_prf, optrand_p, msg, msg_len);
    
      sig = s_sig;
      offset = 0;
    sig, _ = _x_memcpy_u8pu8<SPX_N>(sig, offset, randomness_p);
      s_sig = sig;

  // hash_message(mhash, &tree, &idx_leaf, sig, pk, m, mlen, &ctx);
  //                                        || 
  //                                        \/
  //                         Here, the 1st SPX_N bytes of sig
  //                         are the randomness bytes
    pk = s_pk;
    tree = s_tree;
    idx_leaf = s_idx_leaf;
    msg_len = s_msg_len;
    msg = s_msg;
    mhash_p = mhash;
  mhash_p, tree, idx_leaf = _hash_message<SPX_N>(mhash_p, tree, idx_leaf, randomness_p, pk, msg, msg_len);
    s_tree = tree;
    s_idx_leaf = s_idx_leaf;
    mhash = mhash_p;
  
  // sig += SPX_N;
  s_sig += SPX_N;

  // set_tree_addr(wots_addr, tree);
  tree = s_tree;
  wots_addr_p = wots_addr;
  wots_addr_p = __set_tree_addr(wots_addr_p, tree);

  // set_keypair_addr(wots_addr, idx_leaf);
  idx_leaf = s_idx_leaf;
  wots_addr_p = __set_keypair_addr(wots_addr_p, idx_leaf);
  wots_addr = wots_addr_p;

  // fors_sign(sig, root, mhash, &ctx, wots_addr);
    sig = s_sig;
    root_p = root;
    mhash_p = mhash;
    pub_seed_p = pub_seed;
    sk_seed_p = sk_seed;
    wots_addr_p = wots_addr;
  root_p = _fors_sign(sig, root_p, mhash_p, pub_seed_p, sk_seed_p, wots_addr_p);
    root = root_p;

  // sig += SPX_FORS_BYTES;
  s_sig += SPX_FORS_BYTES;

  ?{}, i = #set0_32();
  while (i < SPX_D)
  {
    s_i = i;

    // set_layer_addr(tree_addr, i);
    tree_addr = __set_layer_addr(tree_addr, i);

    // set_tree_addr(tree_addr, tree);
    tree = s_tree;
    tree_addr = __set_tree_addr(tree_addr, tree);

    // copy_subtree_addr(wots_addr, tree_addr);
    wots_addr = __copy_subtree_addr(wots_addr, tree_addr);

    // set_keypair_addr(wots_addr, idx_leaf);
    wots_addr = __set_keypair_addr(wots_addr, idx_leaf);

    // merkle_sign(sig, root, &ctx, wots_addr, tree_addr, idx_leaf);
            sig = s_sig;
            auth_path_p = auth_path;
            auth_path_p = __load_u8_array<SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES>(auth_path_p, sig);
    root_p = root;
    pub_seed_p = pub_seed;
    sk_seed_p = sk_seed;
    idx_leaf = s_idx_leaf;
    
            sig = s_sig; // TODO: Rewrite merkle sign but with reg u64 instead of reg ptr u8
            __store_u8_array<SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES>(auth_path_p, sig); // TODO: Rewrite merkle sign but with reg u64 instead of reg ptr u8
            auth_path = auth_path_p;

    //sig += SPX_WOTS_BYTES + SPX_TREE_HEIGHT * SPX_N;
    s_sig += SPX_WOTS_BYTES + SPX_TREE_HEIGHT * SPX_N;

    // idx_leaf = (tree & ((1 << SPX_TREE_HEIGHT) - 1));
    k = (1 << SPX_TREE_HEIGHT) - 1;
    idx_leaf = s_tree;
    t = k;
    idx_leaf &= t;
    s_idx_leaf = idx_leaf;

    // tree = tree >> SPX_TREE_HEIGHT;
    ?{}, tree = #SHR(tree, SPX_TREE_HEIGHT);
    s_tree = tree;

    i = s_i;
    i += 1;
  }
}

#[returnaddress="stack"]
fn _crypto_sign_signature(
  reg u64 sig,
  reg u64 msg,
  reg u64 msg_len,
  reg ptr u8[SPX_SK_BYTES] sk
)
{
  __crypto_sign_signature(sig, msg, msg_len, sk);
}

inline fn ___crypto_sign_signature_(
  reg u64 r sig _sig_len m mlen _sk
) -> reg u64
{
  stack u64 s_sig_len;

  s_sig_len = _sig_len; // spill

  stack u8[SPX_SK_BYTES] sk;
  reg ptr u8[SPX_SK_BYTES] sk_p;

  sk_p = sk;
  sk_p  = __load_u8_array<SPX_SK_BYTES>(sk_p, _sk);

  _crypto_sign_signature(sig, m, mlen, sk_p);

  _sig_len = s_sig_len; // unspill
  [_sig_len] = SPX_BYTES;

  ?{}, r = #set0();
  return r;
}

// return -1 se root e pub_root nao forem iguais
// return 0 caso contrario
inline fn __crypto_sign_verify(
  reg u64 sig,
  reg u64 sig_len,
  reg u64 msg,
  reg u64 msg_len,
  reg ptr u8[SPX_PK_BYTES] pk,
  reg u64 retval
) -> reg u64
{
  ////// spills
  stack u64 s_sig;
  stack u64 s_sig_len;
  stack u64 s_msg;
  stack u64 s_msg_len;
  stack ptr u8[SPX_PK_BYTES] s_pk;
  /////

    stack u8[SPX_N] pub_seed;
  reg ptr u8[SPX_N] pub_seed_p;

  stack u8[SPX_N] sk_seed;
  reg ptr u8[SPX_N] sk_seed_p;

  stack u8[SPX_FORS_MSG_BYTES] mhash;
  reg ptr u8[SPX_FORS_MSG_BYTES] mhash_p;
  
  stack u8[SPX_WOTS_BYTES] wots_pk;
  reg ptr u8[SPX_WOTS_BYTES] wots_pk_p;

  stack u8[SPX_N] root;
  reg ptr u8[SPX_N] root_p;

  stack u8[SPX_N] leaf;
  reg ptr u8[SPX_N] leaf_p;

  reg u64 tree;
  stack u64 s_tree;

  reg u32 idx_leaf;
  stack u32 s_idx_leaf;

  stack u32[8] wots_addr;
  reg ptr u32[8] wots_addr_p;

  stack u32[8] tree_addr;
  reg ptr u32[8] tree_addr_p;

  stack u32[8] wots_pk_addr;
  reg ptr u32[8] wots_pk_addr_p;

  stack u8[SPX_N] randomness;
  reg ptr u8[SPX_N] randomness_p;

  reg u64 offset;
  reg u32 type;
  reg u32 addr;

  reg ptr u8[SPX_N] buf;
  reg ptr u8[SPX_N] pub_root_p;

  inline int i;

  reg u32 idx_offset;

  inline int k;
  reg u32 t;
  reg u32 tree_height;

  /// Initial spills
  s_sig = sig;
  s_sig_len = sig_len;
  s_msg = msg;
  s_msg_len = msg_len;
  s_pk = pk;
  ///

  randomness_p = randomness;
  randomness_p = __load_u8_array<SPX_N>(randomness_p, sig);
  randomness = randomness_p;

  // uint32_t wots_addr[8] = {0};
  wots_addr_p = wots_addr;
  wots_addr_p = __zero_array_u32<8>(wots_addr_p);
  wots_addr = wots_addr_p;
  
  // uint32_t tree_addr[8] = {0};
  tree_addr_p = tree_addr;
  tree_addr_p = __zero_array_u32<8>(tree_addr_p);
  tree_addr = tree_addr_p;

  // uint32_t wots_pk_addr[8] = {0};
  wots_pk_addr_p = wots_pk_addr;
  wots_pk_addr_p = __zero_array_u32<8>(wots_pk_addr_p);
  wots_pk_addr = wots_pk_addr_p;

  // memcpy(ctx.pub_seed, pk, SPX_N);
  pub_seed_p = pub_seed;
  offset = 0;
  buf = pk[0:SPX_N];
  pub_seed_p, _ = _x_memcpy_u8u8<SPX_N, SPX_N>(pub_seed_p, offset, buf);
  pub_seed = pub_seed_p;

  // set_type(wots_addr, SPX_ADDR_TYPE_WOTS);
  wots_addr_p = wots_addr;
  type = SPX_ADDR_TYPE_WOTS;
  wots_addr_p = __set_type(wots_addr_p, type);
  wots_addr = wots_addr_p;
  
  // set_type(tree_addr, SPX_ADDR_TYPE_HASHTREE);
  tree_addr_p = tree_addr;
  type = SPX_ADDR_TYPE_HASHTREE;
  tree_addr_p = __set_type(tree_addr_p, type);
  tree_addr = tree_addr_p;

  // set_type(wots_pk_addr, SPX_ADDR_TYPE_WOTSPK);
  wots_pk_addr_p = wots_pk_addr;
  type = SPX_ADDR_TYPE_WOTSPK;
  wots_pk_addr_p = __set_type(wots_pk_addr_p, type);
  wots_pk_addr = wots_pk_addr_p;

  // hash_message(mhash, &tree, &idx_leaf, sig, pk, m, mlen, &ctx);
  mhash_p = mhash;
  randomness_p = randomness;
  msg = s_msg;
  msg_len = s_msg_len;
  mhash_p, tree, idx_leaf = _hash_message<SPX_PK_BYTES>(mhash_p, tree, idx_leaf, randomness_p, pk, msg, msg_len);
  mhash = mhash_p;
  s_tree = tree;
  s_idx_leaf = idx_leaf;
  s_msg = msg; // nao sei se e preciso mas na duvida

  // sig += SPX_N;
  s_sig += SPX_N;

  // set_tree_addr(wots_addr, tree);
  wots_addr_p = wots_addr;
  tree = s_tree;
  wots_addr_p = __set_tree_addr(wots_addr_p, tree);

  // set_keypair_addr(wots_addr, idx_leaf);
  idx_leaf = s_idx_leaf;
  wots_addr_p = __set_keypair_addr(wots_addr_p, idx_leaf);
  wots_addr = wots_addr_p;

  // fors_pk_from_sig(root, sig, mhash, &ctx, wots_addr);
  root_p = root;
  sig = s_sig;
  mhash_p = mhash;
  pub_seed_p = pub_seed;
  sk_seed_p = sk_seed;
  wots_addr_p = wots_addr;
  root_p = _fors_pk_from_sig(root_p, sig, mhash_p, pub_seed_p, sk_seed_p, wots_addr_p);
  root = root_p;  

  // sig += SPX_FORS_BYTES;
  s_sig += SPX_FORS_BYTES;

  for i=0 to SPX_D { // FIXME: TODO: Substituindo por um ciclo while isto deixa de compilar
    // set_layer_addr(tree_addr, i);
    tree_addr_p = tree_addr;
    tree_addr_p = __set_layer_addr(tree_addr_p, i);
    
    // set_tree_addr(tree_addr, tree);
    tree = s_tree;
    tree_addr_p = __set_tree_addr(tree_addr_p, tree);

    // copy_subtree_addr(wots_addr, tree_addr);
    wots_addr_p = wots_addr;
    wots_addr_p = __copy_subtree_addr(wots_addr_p, tree_addr_p);
    tree_addr = tree_addr_p;

    // set_keypair_addr(wots_addr, idx_leaf);
    idx_leaf = s_idx_leaf;
    wots_addr_p = __set_keypair_addr(wots_addr_p, idx_leaf);

    // copy_keypair_addr(wots_pk_addr, wots_addr);
    wots_pk_addr_p = wots_pk_addr;
    wots_pk_addr_p = __copy_keypair_addr(wots_pk_addr_p, wots_addr_p);
    wots_addr = wots_addr_p;

    // wots_pk_from_sig(wots_pk, sig, root, &ctx, wots_addr);
    wots_pk_p = wots_pk;
    sig = s_sig;
    pub_seed_p = root;
    pub_seed_p = pub_seed;
    wots_addr_p = wots_addr;
    wots_pk_p, wots_addr_p = __wots_pk_from_sig_(wots_pk_p, sig, root_p, pub_seed_p, wots_addr_p);
    wots_pk = wots_pk_p;
    wots_addr = wots_addr_p;
    
    // sig += SPX_WOTS_BYTES;
    s_sig += SPX_WOTS_BYTES;

    // thash(leaf, wots_pk, SPX_WOTS_LEN, &ctx, wots_pk_addr);
    leaf_p = leaf;
    wots_pk_p = wots_pk;
    pub_seed_p = pub_seed;
    wots_pk_addr_p = wots_pk_addr;
    leaf_p = _thash<SPX_WOTS_LEN>(leaf_p, wots_pk_p, pub_seed_p, wots_pk_addr_p);
    leaf = leaf_p;

    // compute_root(root, leaf, idx_leaf, 0, sig, SPX_TREE_HEIGHT, &ctx, tree_addr);
    root_p = root;
    leaf_p = leaf;
    idx_leaf = s_idx_leaf;
    idx_offset = 0;
    sig = s_sig;
    tree_height = SPX_TREE_HEIGHT;
    pub_seed_p = pub_seed;
    tree_addr_p = tree_addr;
    root_p, tree_addr_p = __compute_root(root_p, leaf_p, idx_leaf, idx_offset, sig, tree_height, pub_seed_p, tree_addr_p);
    root = root_p;
    tree_addr = tree_addr_p;

    // sig += SPX_TREE_HEIGHT * SPX_N;
    s_sig += SPX_TREE_HEIGHT * SPX_N;

    // idx_leaf = (tree & ((1 << SPX_TREE_HEIGHT) - 1));
    k = (1 << SPX_TREE_HEIGHT) - 1;
    tree = s_tree;
    idx_leaf = tree;
    t = k;
    idx_leaf &= t;
    s_idx_leaf = idx_leaf;

    // tree = tree >> SPX_TREE_HEIGHT;
    ?{}, tree = #SHR(tree, SPX_TREE_HEIGHT);
    s_tree = tree;
  }

  pk = s_pk;
  pub_root_p = pk[SPX_N : SPX_N];
  root_p = root;
  retval = __memcmp<SPX_N>(root_p, pub_root_p, retval);

  return retval;
}

#[returnaddress="stack"]
fn _crypto_sign_verify(
  reg u64 sig,
  reg u64 sig_len,
  reg u64 msg,
  reg u64 msg_len,
  reg ptr u8[SPX_PK_BYTES] pk,
  reg u64 retval
) -> reg u64
{
  retval = __crypto_sign_verify(sig, sig_len, msg, msg_len, pk, retval);
  return retval;
}

inline fn __crypto_sign_verify__(
  reg u64 sig,
  reg u64 sig_len,
  reg u64 msg,
  reg u64 msg_len,
  reg ptr u8[SPX_PK_BYTES] pk,
  reg u64 retval
) -> reg u64
{
  sig = sig;
  sig_len = sig_len;
  msg = msg;
  msg_len = msg_len;
  pk = pk;
  retval = retval;

  retval = _crypto_sign_verify(sig, sig_len, msg, msg_len, pk, retval);
  
  retval = retval;
  
  return retval;
}

inline fn __crypto_sign_verify_(
  reg u64 sig,
  reg u64 sig_len,
  reg u64 m,
  reg u64 m_len,
  reg u64 _pk,
  reg u64 r
) -> reg u64
{
  stack u8[SPX_PK_BYTES] pk;
  reg ptr u8[SPX_PK_BYTES] pk_p;

  if (sig_len != SPX_BYTES) {
    r = -1;
  } else {
    pk_p = pk;
    pk_p = __load_u8_array<SPX_PK_BYTES>(pk_p, _pk);
    r = _crypto_sign_verify(sig, sig_len, m, m_len, pk_p, r);
   }

  return r;
}

inline fn __crypto_sign(
  reg u64 r sm _sm_len m mlen _sk
) -> reg u64
{
  reg u64 sm_len;
 
  stack u8[SPX_SK_BYTES] sk;
  reg ptr u8[SPX_SK_BYTES] sk_p;

  reg u64 i;
  reg u8 t;

  stack u64 s_sm_len;

  stack u64 s_sm s_m s_mlen;

  s_sm_len = _sm_len; // spill

  sk_p = sk;
  sk_p  = __load_u8_array<SPX_SK_BYTES>(sk_p, _sk);

  s_sm = sm; s_m = m; s_mlen = mlen; // register swap
  sm = s_sm; m = s_m; mlen = s_mlen; // register swap
  _crypto_sign_signature(sm, m, mlen, sk_p); 

  // memmove(sm + SPX_BYTES, m, mlen);
  ?{}, i = #set0();
  mlen = s_mlen;
  m = s_m;
  sm = s_sm;
  while (i < mlen)
  {
    t = (u8)[m + i];
    (u8)[sm + SPX_BYTES + i] = t;
    i += 1;
  }

  // *smlen = siglen + mlen;
  _sm_len = s_sm_len;
  sm_len = SPX_BYTES;
  sm_len += s_mlen;
  [_sm_len] = sm_len;

  ?{}, r = #set0();
  return r;
}

inline fn __crypto_sign_open(
  reg u64 msg,
  reg u64 msg_len,
  reg u64 sm,
  reg u64 sm_len,
  reg u64 _pk,
  reg u64 r
) -> reg u64 
{
  stack u8[SPX_PK_BYTES] pk;
  reg ptr u8[SPX_PK_BYTES] pk_p;

  reg u64 len l;
  reg u8 val;
  reg u64 i;

  stack u64 sm_entry; // sm at the entrypoint of the program
  stack u64 s_msg s_sm s_sm_len s_msg_len; // spill

  // if (smlen < SPX_BYTES) { memset(m, 0, smlen); *mlen = 0; return -1; }
  if (sm_len < SPX_BYTES)
  {
    val = 0;
    __memset(msg, val, sm_len);
    (u64)[msg_len] = 0;
    r = -1;
  } else {
    sm_entry = sm;
    s_sm_len = sm_len; // spill
    s_sm = sm; // spill
    s_msg_len = msg_len; // spill
    s_msg = msg; // spill

    pk_p = pk;
    pk_p = __load_u8_array<SPX_PK_BYTES>(pk_p, _pk);  

    // *mlen = smlen - SPX_BYTES;
    len = sm_len;
    len -= SPX_BYTES;
    (u64)[msg_len] = len;
    
    // if (crypto_sign_verify(sm, SPX_BYTES, sm + SPX_BYTES, (size_t)*mlen, pk))
    //     memset(m, 0, smlen); *mlen = 0; return -1;
    len = SPX_BYTES;
    sm += SPX_BYTES;
    l = (u64)[msg_len];
    r = __crypto_sign_verify__(sm, len, sm, l, pk_p, r);

    msg = s_msg; // unspill
    msg_len = s_msg_len; // unspill
    
    if (r != 0) 
    {
      val = 0;
      sm_len = s_sm_len;   // unspill
      __memset(msg, val, sm_len);
      (u64)[msg_len] = 0;
      r = -1;
    }

    // memmove(m, sm + SPX_BYTES, *mlen);
    sm = s_sm; // unspill
    len = (u64)[msg_len];
    ?{}, i = #set0();
    while (i < len)
    {
      val = (u8)[sm + SPX_BYTES + i];
      (u8)[msg + i] = val;
      i += 1;
    }
  }

  return r;
}