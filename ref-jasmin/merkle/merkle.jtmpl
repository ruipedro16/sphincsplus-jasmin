from Sphincs require "address/address.jinc"
from Sphincs require "generic/utils.jtmpl"
from Sphincs require "wots/wots.jtmpl"
from Sphincs require "wotsx1/wotsx1.jtmpl"

// NOTE:  idx_offset is always zero
//        tree_height is always SPX_TREE_HEIGHT
//        Because idx_offset is always zero, so is internal_idx_offset
inline fn __treehash_wots(
  reg ptr u8[SPX_N] root,
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N] auth_path,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg u32 leaf_idx,
  reg ptr u32[8] tree_addr,
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] wots_sig, // struct info
  reg u32 wots_sign_leaf, // struct info
  reg ptr u32[SPX_WOTS_LEN] wots_steps, // struct info
  reg ptr u32[8] leaf_addr,
  reg ptr u32[8] pk_addr // struct info
) -> reg ptr u8[SPX_N],
     reg ptr u8[SPX_TREE_HEIGHT * SPX_N],
     reg ptr u32[8],
     reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES],
     reg ptr u32[8],
     reg ptr u32[8]
{
  ////////////
  /// Variables to spill
  stack ptr u8[SPX_N] s_root;
  stack ptr u8[SPX_TREE_HEIGHT * SPX_N] s_auth_path;
  stack ptr u8[SPX_N] s_pub_seed;
  stack ptr u8[SPX_N] s_sk_seed;
  stack u32 s_leaf_idx;
  stack ptr u32[8] s_tree_addr;
  stack ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] s_wots_sig;
  stack u32 s_wots_sign_leaf;
  stack ptr u32[SPX_WOTS_LEN] s_wots_steps;
  stack ptr u32[8] s_leaf_addr;
  stack ptr u32[8] s_pk_addr;

  ////////////
  stack u8[2 * SPX_N] current;
  reg ptr u8[2 * SPX_N] current_p;
  reg ptr u8[SPX_N] buf;

  reg u32 idx;
  reg u32 temp;

  stack u8[SPX_TREE_HEIGHT * SPX_N] nodes;
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N] nodes_p;

  stack u32 s_exit_outer_loop s_exit_inner_loop;

  stack u32 s_idx s_internal_idx_offset s_internal_idx s_internal_leaf s_h;
  stack u64 s_h_spx_n;

  reg u64 out_offset in_offset bytes;
  
  reg u32 idx r_max_idx;
  reg bool cond;

  inline u32 max_idx;

  ////////////

  // Initial Spills
  s_root = root; s_auth_path = auth_path; s_pub_seed = pub_seed; 
  s_sk_seed = sk_seed; s_leaf_idx = leaf_idx; s_tree_addr = tree_addr; 
  s_wots_sig = wots_sig; s_wots_sign_leaf = wots_sign_leaf; 
  s_wots_steps = wots_steps; s_leaf_addr = leaf_addr; s_pk_addr = pk_addr;

  max_idx = (1 << SPX_TREE_HEIGHT) - 1;

  // for (idx = 0;; idx++)
  s_idx = 0;
  s_exit_outer_loop = 0;
  while (s_exit_outer_loop != 1)
  {
    current = __zero_array_u8<2*SPX_N>(current); // FIXME: Remove this later

    // gen_leaf( &current[SPX_N], ctx, idx + idx_offset, info );
    buf = current[SPX_N : SPX_N];
    pub_seed = s_pub_seed;
    sk_seed = s_sk_seed;
    temp = s_idx; // idx offset = 0 so idx + idx_offset = idx
    wots_sig = s_wots_sig;
    wots_sign_leaf = s_wots_sign_leaf;
    wots_steps = s_wots_steps;
    leaf_addr = s_leaf_addr;
    pk_addr = s_pk_addr;

    buf, wots_sig, leaf_addr, pk_addr = __wots_gen_leafx1_(buf, 
                                                         pub_seed, 
                                                         sk_seed,
                                                         temp, // leaf_idx
                                                         wots_sig,
                                                         wots_sign_leaf,
                                                         wots_steps,
                                                         leaf_addr,
                                                         pk_addr);

    current[SPX_N:SPX_N] = buf;
    s_wots_sig = wots_sig;
    s_leaf_addr = leaf_addr;
    s_pk_addr = pk_addr;

    // uint32_t internal_idx = idx;
    temp = s_idx; 
    s_internal_idx = temp;

    // uint32_t internal_leaf = leaf_idx;
    temp = s_leaf_idx; 
    s_internal_leaf = temp;

    // for (h=0;; h++, internal_idx >>= 1, internal_leaf >>= 1)
    s_h = 0;
    s_h_spx_n = 0;
    s_exit_inner_loop = 0;
    while(s_exit_inner_loop == 0) 
    {
      // if (h == tree_height) { memcpy( root, &current[SPX_N], SPX_N ); return; } 
      if (s_h == SPX_TREE_HEIGHT)
      {
        root = s_root;
        out_offset = 0;
        buf = current[SPX_N : SPX_N];

        root, _ = _x_memcpy_u8u8<SPX_N, SPX_N>(root, out_offset, buf);
        s_root = root;

        s_exit_inner_loop = 1;
        s_exit_outer_loop = 1;
      } else {
        // if ((internal_idx ^ internal_leaf) == 0x01) 
        //      memcpy( &auth_path[ h * SPX_N ], &current[SPX_N], SPX_N );}
        temp = s_internal_idx;
        temp ^= s_internal_leaf;
        if (temp == 1)
        {
          auth_path = s_auth_path;
          out_offset = s_h_spx_n;
          buf = current[SPX_N : SPX_N];
          auth_path, _ = _x_memcpy_u8u8<SPX_TREE_HEIGHT * SPX_N, SPX_N>(auth_path, out_offset, buf);
          s_auth_path = auth_path;
        }

        // if ((internal_idx & 1) == 0 && idx < max_idx) { break; }
        temp = s_internal_idx; temp &= 1;
        idx = s_idx;
        r_max_idx = max_idx; // TODO: add inline int to conditions library to avoid this
        cond = __cond_u32_a_eq_b_and_c_below_d(temp, 0, idx, r_max_idx);

        if(cond)
        {
          s_exit_inner_loop = 1;
        } else {
          // set_tree_height(tree_addr, h + 1);
          tree_addr = s_tree_addr;
          temp = s_h; temp += 1;
          tree_addr = __set_tree_height(tree_addr, temp);
          
          // set_tree_index(tree_addr, internal_idx/2 + internal_idx_offset );
          temp = s_internal_idx; 
          temp >>= 1;
          tree_addr = __set_tree_index(tree_addr, temp);
          s_tree_addr = tree_addr;

          // unsigned char *left = &stack[h * SPX_N];
          // memcpy( &current[0], left, SPX_N);
          // Same as:
          // memcpy( &current[0], &stack[h * SPX_N], SPX_N);
          buf = current[0:SPX_N];
          out_offset = 0;
          nodes_p = nodes;
          in_offset = s_h_spx_n;
          bytes = SPX_N;
          buf, _, _ =
            _x_memcpy_u8u8_2<SPX_N,SPX_TREE_HEIGHT*SPX_N>(buf,
                                                          out_offset,
                                                          nodes_p,
                                                          in_offset,
                                                          bytes);
          current[0:SPX_N] = buf;

          // thash( &current[1 * SPX_N], &current[0 * SPX_N], 2, ctx, tree_addr);
          buf = current[SPX_N:SPX_N];
          current_p = current;
          pub_seed = s_pub_seed;
          tree_addr = s_tree_addr;
          buf = __thash<2>(buf, current_p, pub_seed, tree_addr);
          current[SPX_N:SPX_N] = buf;
        }
      }

      if (s_exit_inner_loop == 0)
      {
        s_h += 1;
        s_h_spx_n += SPX_N;
        s_internal_idx >>= 1;
        s_internal_leaf >>= 1;
      }
    } // end: C: for (h=0;; h++, internal_idx >>= 1, internal_leaf >>= 1)
      //      Jasmin: while(s_exit_inner_loop == 0)
    
    // memcpy( &stack[h * SPX_N], &current[SPX_N], SPX_N);
    if (s_exit_outer_loop != 1) // i.e if we havent broken out of the loop yet
                                // no need to memcpy if s_exit_outer_loop == 1
    {
      nodes_p = nodes;
      out_offset = s_h_spx_n;
      buf = current[SPX_N:SPX_N];
      nodes_p, _ = _x_memcpy_u8u8<SPX_TREE_HEIGHT*SPX_N,SPX_N>(nodes_p,
                                                               out_offset,
                                                               buf);
      nodes = nodes_p;

      s_idx += 1;
    }
  } // end: C: for (idx = 0;; idx++) 
    // Jasmin: while(s_exit_outer_loop == 0)

  // Unspill before returning
  root = s_root; auth_path = s_auth_path; tree_addr = s_tree_addr;
  wots_sig = s_wots_sig; leaf_addr = s_leaf_addr; pk_addr = s_pk_addr;

  return root, auth_path, tree_addr, wots_sig, leaf_addr, pk_addr;
}


#[returnaddress="stack"]
fn _treehash_wots(
  reg ptr u8[SPX_N] root,
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N] auth_path,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg u32 leaf_idx,
  reg ptr u32[8] tree_addr,
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] wots_sig, // struct info
  reg u32 wots_sign_leaf, // struct info
  reg ptr u32[SPX_WOTS_LEN] wots_steps, // struct info
  reg ptr u32[8] leaf_addr pk_addr // struct info
) -> reg ptr u8[SPX_N],
     reg ptr u8[SPX_TREE_HEIGHT * SPX_N],
     reg ptr u32[8],
     reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES],
     reg ptr u32[8],
     reg ptr u32[8]
{
  root, auth_path, tree_addr, wots_sig, leaf_addr, pk_addr = 
                          __treehash_wots(root, auth_path, pub_seed, 
                                           sk_seed, leaf_idx, tree_addr, 
                                           wots_sig, wots_sign_leaf, wots_steps, 
                                           leaf_addr, pk_addr);

  return root, auth_path, tree_addr, wots_sig, leaf_addr, pk_addr;
}

inline fn __merkle_sign(
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] sig, // auth_path
  reg ptr u8[SPX_N] root,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] wots_addr tree_addr,
  reg u32 idx_leaf
) -> reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES], 
     reg ptr u8[SPX_N],
     reg ptr u32[8]
{
  stack ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] s_sig;
  stack ptr u8[SPX_N] s_root;
  stack ptr u8[SPX_N] s_pub_seed;
  stack ptr u8[SPX_N] s_sk_seed;
  stack ptr u32[8] s_wots_addr s_tree_addr;
  stack u32 s_idx_leaf;

  stack u32[SPX_WOTS_LEN] steps;
  reg ptr u32[SPX_WOTS_LEN] steps_p;

  // struct leaf_info
  stack u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] wots_sig;
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] wots_sig_p;

  reg u32 wots_sign_leaf;
  stack u32[8] leaf_addr pk_addr;
  stack u32[SPX_WOTS_LEN] wots_steps; // TODO: WE DO NOT NEED   THIS VARIABLKE I THINk
  // struct leaf info

  reg u32 addr type;

  reg u64 offset;

  reg ptr u8[SPX_TREE_HEIGHT * SPX_N] buf;

  leaf_addr = __zero_array_u32<8>(leaf_addr);
  pk_addr = __zero_array_u32<8>(pk_addr);

  // Spill
  s_sig = sig;
  s_root = root;
  s_pub_seed = pub_seed;
  s_sk_seed = sk_seed;
  s_wots_addr = wots_addr;
  s_tree_addr = tree_addr;
  s_idx_leaf = idx_leaf;

  // info.wots_sig = sig;
  // Note: In the end [i.e. after wots_sig is updated], we have to memcpy back to sig
  wots_sig_p = wots_sig;
  offset = 0;
  wots_sig_p, _ = _x_memcpy_u8u8<SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES, SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES>(wots_sig_p, offset, sig);
  wots_sig = wots_sig_p;

  // NOTE: Nao deveria ser preciso um memcpy. EM C basta fazer wots_sig = sig. Mas em Jasmin isto provoca
  // compilation error in function merkle_gen_root_jazz:
  // stack allocation: the region associated to variable s_wots_sig
  // TODO: FIXME: TODO: FIXME: Rever isto no fim

  // chain_lengths(steps, root);
  steps_p = steps;
  steps_p = __chain_lengths(steps_p, root);
  steps = steps_p;

  // info.wots_steps = steps; [This step is not needed I think]
  // wots_steps = steps;

  // set_type(&tree_addr[0], SPX_ADDR_TYPE_HASHTREE);
  tree_addr = s_tree_addr;
  type = SPX_ADDR_TYPE_HASHTREE;
  tree_addr = __set_type(tree_addr, type);
  s_tree_addr = tree_addr;

  // set_type(&info.pk_addr[0], SPX_ADDR_TYPE_WOTSPK);
  type = SPX_ADDR_TYPE_WOTSPK;
  pk_addr = __set_type(pk_addr, type);

  // copy_subtree_addr(&info.leaf_addr[0], wots_addr);
  leaf_addr = __copy_subtree_addr(leaf_addr, wots_addr);

  // copy_subtree_addr(&info.pk_addr[0], wots_addr);
  pk_addr = __copy_subtree_addr(pk_addr, wots_addr);

  // info.wots_sign_leaf = idx_leaf;
  wots_sign_leaf = s_idx_leaf;

  idx_leaf = s_idx_leaf; // This should be live (no need to retrieve it from the stack ?)
  buf = sig[SPX_WOTS_BYTES:SPX_TREE_HEIGHT * SPX_N];
  tree_addr = s_tree_addr; // This should be live (no need to retrieve it from the stack ?)
  root, buf, tree_addr, wots_sig_p, leaf_addr, pk_addr = 
    __treehash_wots(root, 
                    buf, 
                    pub_seed, sk_seed, 
                    idx_leaf, tree_addr, 
                    wots_sig, 
                    wots_sign_leaf, 
                    steps, 
                    leaf_addr, 
                    pk_addr);
  sig[SPX_WOTS_BYTES:SPX_TREE_HEIGHT * SPX_N] = buf;

  return sig, root, tree_addr;
}

#[returnaddress="stack"]
fn _merkle_sign(
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] sig, // auth_path
  reg ptr u8[SPX_N] root,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] wots_addr,
  reg ptr u32[8] tree_addr,
  reg u32 idx_leaf
) -> reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES], 
     reg ptr u8[SPX_N],
     reg ptr u32[8]
{
  sig, root, tree_addr = __merkle_sign(sig, root, pub_seed, sk_seed, wots_addr, tree_addr, idx_leaf);
  return sig, root, tree_addr;
}

inline fn __merkle_sign_(
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] sig, // auth_path
  reg ptr u8[SPX_N] root,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] wots_addr,
  reg ptr u32[8] tree_addr,
  reg u32 idx_leaf
) -> reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES], 
     reg ptr u8[SPX_N],
     reg ptr u32[8]
{
  stack ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] s_sig;
  stack ptr u8[SPX_N] s_root;
  stack ptr u8[SPX_N] s_pub_seed;
  stack ptr u8[SPX_N] s_sk_seed;
  stack ptr u32[8] s_wots_addr;
  stack ptr u32[8] s_tree_addr;
  stack u32 s_idx_leaf;

  // Spill
  s_root = root;
  s_pub_seed = pub_seed;
  s_sk_seed = sk_seed;
  s_wots_addr = wots_addr;
  s_tree_addr = tree_addr;
  s_idx_leaf = idx_leaf;


  // Unspill
  root = s_root;
  pub_seed = s_pub_seed;
  sk_seed = s_sk_seed;
  wots_addr = s_wots_addr;
  tree_addr = s_tree_addr;
  idx_leaf = s_idx_leaf;

  sig, root, tree_addr = __merkle_sign(sig, root, pub_seed, sk_seed, wots_addr, tree_addr, idx_leaf);

  sig = sig;
  root = root;
  tree_addr = tree_addr;

  return sig, root, tree_addr;
}

inline fn __merkle_gen_root(
  reg ptr u8[SPX_N] root,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed
) -> reg ptr u8[SPX_N]
{
  stack u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] auth_path;
  reg ptr u8[SPX_TREE_HEIGHT * SPX_N + SPX_WOTS_BYTES] auth_path_p;

  stack u32[8] top_tree_addr; 
  reg ptr u32[8] top_tree_addr_p; 
  
  stack u32[8] wots_addr;
  reg ptr u32[8] wots_addr_p;

  reg u32 t;
  reg u32 addr;
  inline int i;
  
  ?{}, t = #set0_32();

  top_tree_addr_p = top_tree_addr;
  wots_addr_p = wots_addr;

  for i=0 to 8 {
    top_tree_addr_p[i] = t;
    wots_addr_p[i] = t;
  }

  addr = SPX_D - 1;
  top_tree_addr_p = __set_layer_addr(top_tree_addr_p, addr);
  wots_addr_p = __set_layer_addr(wots_addr_p, addr);
  
  auth_path_p = auth_path;
  t = #NOT_32(t);
  _, root, _ = _merkle_sign(auth_path_p, root, pub_seed, sk_seed, wots_addr_p, top_tree_addr_p, t);

  return root;
}

#[returnaddress="stack"]
fn _merkle_gen_root(
  reg ptr u8[SPX_N] root,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed
) -> reg ptr u8[SPX_N]
{
  root = __merkle_gen_root(root, pub_seed, sk_seed);
  return root;
}