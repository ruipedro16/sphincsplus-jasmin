from Sphincs require "address/address.jinc"
from Sphincs require "hash/hash_shake.jtmpl"
from Sphincs require "utils/utils.jinc"
from Sphincs require "generic/conditions.jinc"

////////////////// GEN SK /////////////////////////////////////////////////////

inline fn __fors_gen_sk(
  reg ptr u8[SPX_N] sk,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] fors_leaf_addr
) -> reg ptr u8[SPX_N]
{
  sk = __prf_addr(sk, pub_seed, sk_seed, fors_leaf_addr);
  return sk;
}

#[returnaddress="stack"]
fn _fors_gen_sk(
  reg ptr u8[SPX_N] sk,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] fors_leaf_addr
) -> reg ptr u8[SPX_N]
{
  sk = __fors_gen_sk(sk, pub_seed, sk_seed, fors_leaf_addr);
  return sk;
}

inline fn __fors_gen_sk__(
  reg ptr u8[SPX_N] sk,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] fors_leaf_addr
) -> reg ptr u8[SPX_N]
{
  sk = sk;
  pub_seed = pub_seed;
  sk_seed = sk_seed;
  fors_leaf_addr = fors_leaf_addr;

  sk = _fors_gen_sk(sk, pub_seed, sk_seed, fors_leaf_addr);
  
  sk = sk;
  pub_seed = pub_seed;
  sk_seed = sk_seed;
  fors_leaf_addr = fors_leaf_addr;

  return sk;
}

////////////////// SK TO LEAF /////////////////////////////////////////////////

inline fn __fors_sk_to_leaf(
  reg ptr u8[SPX_N] leaf,
  reg ptr u8[SPX_N] sk, // INBLOCKS = 1 so SPX_N * INBLOCKS = SPX_N
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u32[8] fors_leaf_addr
) -> reg ptr u8[SPX_N]
{
  leaf = __thash_<1>(leaf, sk, pub_seed, fors_leaf_addr);
  return leaf;
}

#[returnaddress="stack"]
fn _fors_sk_to_leaf(
  reg ptr u8[SPX_N] leaf,
  reg ptr u8[SPX_N] sk,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u32[8] fors_leaf_addr
) -> reg ptr u8[SPX_N]
{
  leaf = __fors_sk_to_leaf(leaf, sk, pub_seed, fors_leaf_addr);
  return leaf;
}

inline fn __fors_sk_to_leaf__(
  reg ptr u8[SPX_N] leaf,
  reg ptr u8[SPX_N] sk,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u32[8] fors_leaf_addr
) -> reg ptr u8[SPX_N]
{
  leaf = leaf; leaf = leaf; sk = sk; pub_seed = pub_seed; fors_leaf_addr = fors_leaf_addr;
  leaf = _fors_sk_to_leaf(leaf, sk, pub_seed, fors_leaf_addr);
  leaf = leaf; leaf = leaf; sk = sk; pub_seed = pub_seed; fors_leaf_addr = fors_leaf_addr;
  return leaf;
}

////////////////// GEN LEAF ///////////////////////////////////////////////////
inline fn __fors_gen_leafx1(
  reg ptr u8[SPX_N] leaf,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg u32 addr_idx,
  reg ptr u32[8] fors_leaf_addr // void* info in ref impl
) -> reg ptr u8[SPX_N], reg ptr u32[8]
{
  stack ptr u8[SPX_N] s_pub_seed;
  stack ptr u8[SPX_N] s_sk_seed;
  stack u32 s_addr_idx;
  stack ptr u32[8] s_fors_leaf_addr;
  
  inline int i; 
  reg u8 t;

  fors_leaf_addr = __set_tree_index(fors_leaf_addr, addr_idx);
  fors_leaf_addr = __set_type(fors_leaf_addr, SPX_ADDR_TYPE_FORSPRF);
  
  s_pub_seed = pub_seed; 
  s_sk_seed = sk_seed; 
  s_addr_idx = s_addr_idx; 
  s_fors_leaf_addr = fors_leaf_addr;

  leaf = __fors_gen_sk__(leaf, pub_seed, sk_seed, fors_leaf_addr); 
  
  fors_leaf_addr = s_fors_leaf_addr;
  fors_leaf_addr = __set_type(fors_leaf_addr, SPX_ADDR_TYPE_FORSTREE);

  pub_seed = s_pub_seed;
  leaf = __thash_inplace_(leaf, pub_seed, fors_leaf_addr);
  
  return leaf, fors_leaf_addr;
}

#[returnaddress="stack"]
fn _fors_gen_leafx1(
  reg ptr u8[SPX_N] leaf,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg u32 addr_idx,
  reg ptr u32[8] fors_leaf_addr
) -> reg ptr u8[SPX_N], reg mut ptr u32[8]
{
  leaf, fors_leaf_addr = __fors_gen_leafx1(leaf, pub_seed, sk_seed, addr_idx, fors_leaf_addr);
  return leaf, fors_leaf_addr;
}

inline fn __fors_gen_leafx1__(
  reg ptr u8[SPX_N] leaf,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg u32 addr_idx,
  reg ptr u32[8] fors_leaf_addr
) -> reg ptr u8[SPX_N], reg ptr u32[8]
{
  leaf = leaf; pub_seed = pub_seed; sk_seed = sk_seed; addr_idx = addr_idx; fors_leaf_addr = fors_leaf_addr;
  leaf, fors_leaf_addr = _fors_gen_leafx1(leaf, pub_seed, sk_seed, addr_idx, fors_leaf_addr);
  leaf = leaf; pub_seed = pub_seed; sk_seed = sk_seed; addr_idx = addr_idx; fors_leaf_addr = fors_leaf_addr;
  return leaf, fors_leaf_addr;
}

inline fn __message_to_indices(
  reg ptr u32[SPX_FORS_TREES] indices,
  reg u64 m // Assumes m contains at least SPX_FORS_HEIGHT * SPX_FORS_TREES bits.
) -> reg ptr u32[SPX_FORS_TREES]
{
  // TODO: Replace with while loops
  inline int i j;
  
  reg u64 offset zero;
  reg u64 t u z v;

  ?{}, zero = #set0();
  offset = 0;

  for i = 0 to SPX_FORS_TREES {
    indices[i] = zero;
    
    for j = 0 to SPX_FORS_HEIGHT {
      // indices[i] ^= ((m[offset >> 3] >> (~offset & 0x7)) & 0x1) << (SPX_FORS_HEIGHT-1-j);
      t = offset;
      t = #SHR(t, 3); // index to access m

      u = offset;  
      u = #NOT(u); 
      u &= 0x7;    

      z = [m + t];
      z = #SHR(z, u);

      z &= 0x1;
      v = SPX_FORS_HEIGHT;
      v -= 1;
      v -= j;
      z = #SHL(z, v);

      indices[i] ^= z;
      offset += 1;
    }
  }
  return indices;
}

// same as __message_to_indices but m is a reg ptr u8[MSG_LEN] instead of reg u64
inline fn __message_to_indices_t<MSG_LEN>(
  reg ptr u32[SPX_FORS_TREES] indices,
  reg ptr u8[MSG_LEN] m // Assumes m contains at least SPX_FORS_HEIGHT * SPX_FORS_TREES bits.
) -> reg ptr u32[SPX_FORS_TREES]
{
  // TODO: Replace with while loops
  inline int i j;
  
  reg u64 offset zero;
  reg u64 t u z v;

  ?{}, zero = #set0();
  offset = 0;

  for i = 0 to SPX_FORS_TREES {
    indices[i] = zero;
    
    for j = 0 to SPX_FORS_HEIGHT {
      // indices[i] ^= ((m[offset >> 3] >> (~offset & 0x7)) & 0x1) << (SPX_FORS_HEIGHT-1-j);
      t = offset;
      t = #SHR(t, 3);

      u = offset;
      u = #NOT(u); 
      u &= 0x7; 

      z = (64u) m[(int) t]; // only this line is different 
      z = #SHR(z, u);

      z &= 0x1;
      v = SPX_FORS_HEIGHT;
      v -= 1;
      v -= j;
      z = #SHL(z, v);

      indices[i] ^= z;
      offset += 1;
    }
  }
  return indices;
}//<>

/////////////////// TREEHASH ////////////////////////////////////////
// for treehash in fors, tree_height is always SPX_FORS_HEIGHT
inline fn treehash_fors(
  reg ptr u8[SPX_N] root,
  reg u64 auth_path,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg u32 leaf_idx,
  reg u32 idx_offset,
  reg ptr u32[8] tree_addr,
  reg ptr u32[8] info
) -> reg ptr u8[SPX_N], reg ptr u32[8], reg ptr u32[8]
{
  ///////////////////////////////////////////////////
  stack ptr u8[SPX_N] s_root;
  stack ptr u8[SPX_N] s_pub_seed;
  stack ptr u8[SPX_N] s_sk_seed;
  stack ptr u32[8] s_info;
  stack u32 s_idx_offset s_leaf_idx;
  stack u64 s_auth_path;
  ///////////////////////////////////////////////////

  stack u8[SPX_FORS_HEIGHT * SPX_N] _stack;
  stack u8[2 * SPX_N] current;

  reg u32 idx max_idx;
  reg u32 internal_idx_offset internal_idx internal_leaf;
  reg u32 h; stack u32 s_h;
  reg u32 t;
  reg u64 u v;

  stack u32 s_idx s_max_idx s_internal_idx_offset s_internal_idx s_internal_leaf s_h s_t;
  stack u64 s_u s_v;

  stack u8 stop_outer stop_inner returned;

  reg u64 offset_h;
  stack u64 s_offset_h;

  reg bool cond;

  inline int i;
  reg u8 t8; stack u8 s_t8;

  ///////////////////////////////////////////////////
  returned = 0;

  max_idx = 1;
  max_idx = #SHL_32(max_idx, SPX_FORS_HEIGHT);
  max_idx -= 1;

  s_max_idx = max_idx;

  idx = 0;
  stop_outer = 0;

  s_pub_seed = pub_seed;
  s_sk_seed = sk_seed;
  s_root = root;
  s_auth_path = auth_path;

  while (stop_outer != 1) {
    s_idx = idx;
    s_idx_offset = idx_offset;

    t = idx;
    t += idx_offset;
    current[SPX_N:SPX_N], info = __fors_gen_leafx1__(current[SPX_N:SPX_N], pub_seed, 
                                                     sk_seed, t, info);
    s_info = info;

    idx = s_idx;               // unspill
    idx_offset = s_idx_offset; // unspill 

    leaf_idx = s_leaf_idx;

    internal_idx_offset = idx_offset;
    internal_idx = idx;
    internal_leaf = leaf_idx;

    s_internal_idx_offset = internal_idx_offset;
    s_internal_idx = internal_idx;
    s_leaf_idx = leaf_idx;
 
    // unspills
    pub_seed = s_pub_seed;
    sk_seed = s_sk_seed ;

    h = 0;
    stop_inner = 0;
    while (stop_inner != 1) {
      s_h = h;

      if (h == SPX_FORS_HEIGHT) {
        root = s_root;
        root, _ = _x_memcpy_u8u8<SPX_N, SPX_N>(root, 0, current[SPX_N:SPX_N]);
        s_root = root;
        stop_inner = 1;
        stop_outer = 1;
        returned = 1;
      }

      if (returned != 1) {
        t = s_internal_idx;
        t = #XOR_32(t, internal_leaf);

        if (t == 0x01) {
          u = s_auth_path;
          v = (64u)s_h;
          v *= SPX_N;
          
          _, _ = _x_memcpy_u8pu8<SPX_N>(u, v, current[SPX_N : SPX_N]);
          
          s_u = u;
          s_v = v;
        }

        // if ((internal_idx & 1) == 0 && idx < max_idx) { break; }
        // t = internal_idx;
        // t &= 1;
// 
        // max_idx = s_max_idx;
        // cond = __cond_u32_a_eq_b_and_c_below_d(t, 0, idx, max_idx); 
        // s_max_idx = max_idx;
// 
        // if (cond) { stop_inner = 1; }

        // We check here because of the break in the previous if
        if (stop_inner != 1) {
          internal_idx_offset = s_internal_idx_offset;
          internal_idx_offset = #SHR_32(internal_idx_offset, 1);
          s_internal_idx_offset = internal_idx_offset;

          t = s_h;
          t += 1;
          
          tree_addr = __set_tree_height(tree_addr, t);

          offset_h = (64u) s_h;
          offset_h *= SPX_N;  
          
          for i=0 to SPX_N {
            t8 = _stack[(int) offset_h];
            current[i] = t8;
            offset_h += 1;
          }
          
          s_t8 = t8;
          s_offset_h = offset_h;

          pub_seed = s_pub_seed;
          // current[SPX_N:SPX_N] = __thash<2>(current[SPX_N:SPX_N], current, pub_seed, tree_addr);
        }
        
      }

      // Update loop
      s_h = h;
      h += 1;
      internal_idx = #SHR_32(internal_idx, 1);
      internal_leaf = #SHR_32(internal_leaf, 1);
    }

    if (returned != 1) {
      offset_h = (64u) s_h;
      offset_h *= SPX_N;
      _stack, _ = _x_memcpy_u8u8<SPX_FORS_HEIGHT * SPX_N, SPX_N>(_stack, offset_h, current[SPX_N:SPX_N]);
      s_offset_h = offset_h;
    }

    // Update loop 
    idx = s_idx;
    idx += 1;
  }

  root = s_root;
  info = s_info;

  return root, tree_addr, info;
}


/////////////////// FORS SIGN ///////////////////////////////////////
inline fn __fors_sign<MSG_LEN>(
  reg u64 sig, // we write to here
  reg ptr u8[SPX_FORS_PK_BYTES] pk,
  reg ptr u8[MSG_LEN] m,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] fors_addr
) 
{
  /////////////////////////////////////////////// spills
  stack u64 s_sig;
  stack ptr u8[SPX_FORS_PK_BYTES] s_pk;
  stack ptr u8[MSG_LEN] s_m;
  stack ptr u8[SPX_N] s_pub_seed;
  stack ptr u8[SPX_N] s_sk_seed;
  stack ptr u32[8] s_fors_addr;
  
  /////////////////////////////////////////////// variable decl

  stack u32[SPX_FORS_TREES] indices;
  stack u8[SPX_FORS_TREES * SPX_N] roots;
  stack u32[8] fors_tree_addr;
  stack u32[8] fors_leaf_addr;
  stack u32[8] fors_pk_addr;

  stack u8[SPX_N] sig_array;

  reg u32 idx_offset;
  inline int i;

  reg u32 t;

  stack u32 s_idx_offset s_t;

  fors_tree_addr = __zero_array_u32<8>(fors_tree_addr);
  fors_leaf_addr = __zero_array_u32<8>(fors_leaf_addr); // struct fors_gen_leaf_info 
  fors_pk_addr   = __zero_array_u32<8>(fors_pk_addr);

  fors_tree_addr = __copy_keypair_addr(fors_tree_addr, fors_addr);
  fors_leaf_addr = __copy_keypair_addr(fors_leaf_addr, fors_addr);

  fors_pk_addr   = __copy_keypair_addr(fors_pk_addr, fors_addr);
  fors_pk_addr = __set_type(fors_pk_addr, SPX_ADDR_TYPE_FORSPK);

  indices = __message_to_indices_t<MSG_LEN>(indices, m);

  
  for i=0 to SPX_FORS_TREES { // TODO: FIXME: Replace with a while loop
    idx_offset = 1;
    idx_offset = #SHL_32(idx_offset, SPX_FORS_HEIGHT);
    idx_offset *= i;

    fors_tree_addr = __set_tree_height(fors_tree_addr, 0);

    t = indices[i]; 
    t += idx_offset; 
    fors_tree_addr = __set_tree_index(fors_tree_addr, t);

    fors_tree_addr = __set_type(fors_tree_addr, SPX_ADDR_TYPE_FORSPRF);

    sig_array = __load_u8_array<SPX_N>(sig_array, sig); // FIXME: impl __fors_gen_sk__ that writes to reg u64

    // spill
    s_sig = sig;
    s_pub_seed = pub_seed;
    s_sk_seed = sk_seed;

    sig_array = __fors_gen_sk__(sig_array, pub_seed, sk_seed, fors_tree_addr);

    sig = s_sig; // unspill
    __store_u8_array<SPX_N>(sig_array, sig); // FIXME: é preciso um shake em q o input e um reg ptr mas o output e um reg u64

    fors_tree_addr = __set_type(fors_tree_addr, SPX_ADDR_TYPE_FORSTREE);
    sig += SPX_N;

    s_sig = sig;

    // TODO: Call to treehash here
    // Wfors_leaf_addr = treehash_fors(roots[i*SPX_N:SPX_N], sig, pub_seed, sk_seed, indices[i], 
    // W                               idx_offset, fors_tree_addr, fors_leaf_addr);

    sig = s_sig;
    sig += SPX_N * SPX_FORS_HEIGHT;

    // unspill data needed for the next iteration
    pub_seed = s_pub_seed;
    sk_seed = s_sk_seed;
  }

}//<>

////////////////////////////////// PK FROM SIG //////////////////////

inline fn __fors_pk_from_sig<MSG_LEN>(
  reg ptr u8[SPX_N] pk, // root
  reg u64 sig,
  reg ptr u8[MSG_LEN] msg,
  reg ptr u8[SPX_N] pub_seed,
  reg ptr u8[SPX_N] sk_seed,
  reg ptr u32[8] fors_addr
)
{

}//<>
