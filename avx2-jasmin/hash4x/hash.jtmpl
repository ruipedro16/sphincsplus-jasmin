from Sphincs require "fips202x4/fips202_4x.jtmpl"

fn _prf_addrx4(
    reg ptr u8[SPX_N] out0,
    reg ptr u8[SPX_N] out1,
    reg ptr u8[SPX_N] out2,
    reg ptr u8[SPX_N] out3,
    reg ptr u8[SPX_N] pub_seed,
    reg ptr u8[SPX_N] sk_seed,
    reg ptr u32[4*8] addr
) -> reg ptr u8[SPX_N], reg ptr u8[SPX_N], reg ptr u8[SPX_N], reg ptr u8[SPX_N]
{
    reg u256[25] state;
    stack u256[25] state_s;
    inline int i;

    stack u64 val; // value to broadcast
    
    // for (int i = 0; i < SPX_N/8; i++) { state[i] = _mm256_set1_epi64x(((int64_t*)ctx->pub_seed)[i]); }
    for i=0 to SPX_N / 8 { state[i] = #VPBROADCAST_4u64(pub_seed[u64 i]); }

    // FIXME: TODO: I dont know which intrinsic to use here

    // for (int i = 0; i < SPX_N/8; i++) { state[SPX_N/8+i+4] = _mm256_set1_epi64x(((int64_t*)ctx->sk_seed)[i]); }
    for i=0 to SPX_N / 8 { state[SPX_N/8 + i + 4] = #VPBROADCAST_4u64(sk_seed[u64 i]); }

    // state[SPX_N/4+4] = _mm256_set1_epi64x(0x1f);
    val = 0x1F;
    state[SPX_N/4 + 4] = #VPBROADCAST_4u64(val);

    // for (int i = SPX_N/4+5; i < 16; i++) { state[i] = _mm256_set1_epi64x(0); }
    val = 0;
    for i=SPX_N/4+5 to 16 { state[i] = #VPBROADCAST_4u64(val); }

    // state[16] = _mm256_set1_epi64x((long long)(0x80ULL << 56));
    val = 0x80;
    val <<= 56;
    state[16] = #VPBROADCAST_4u64(val);

    // for (int i = 17; i < 25; i++) { state[i] = _mm256_set1_epi64x(0); }
    val = 0;
    for i=17 to 25 { state[i] = #VPBROADCAST_4u64(val); }
    
    // state_s = #copy(state);                         // FIXME: array expansion: cannot expand variable state (the default scale must be used)
    // state_s = _KeccakF1600_StatePermute4x(state_s); // FIXME: array expansion: cannot expand variable state (the default scale must be used) 

    for  i=0 to SPX_N/8 {
        out0[u64 i] = #VPEXTR_64(state[i], 0);
        out1[u64 i] = #VPEXTR_64(state[i], 1);
        out2[u64 i] = #VPEXTR_64(state[i], 2);
        out3[u64 i] = #VPEXTR_64(state[i], 3);
    }

    return out0, out1, out2, out3;
}
